import{_ as h,ar as j,as as F,at as Y,au as H,l as i,c as V,av as z,aw as U,ag as $,al as q,ah as P,af as K,ax as Q,ay as W,az as Z}from"./mermaid.core-BN1TdaiK-DQgmrwNI.js";import{G as B}from"./graph-C5Z6IEY7-UfE1Fjd9.js";import{l as I}from"./layout-DwpP2Fho--pf0-mcE.js";import{i as x}from"./_baseUniq-BCzTs16Z-NgNuvKKS.js";import{c as L}from"./clone-04FuOcyX-B8lIw7FM.js";import{m as _}from"./_basePickBy-BSV_1zpR-vkcIusgN.js";import"./index-Dw8Uzof1.js";import"./svelte/svelte_svelte.js";import"./svelte/svelte_animate.js";import"./svelte/svelte_attachments.js";import"./svelte/svelte_easing.js";import"./svelte/svelte_internal_client.js";import"./svelte/svelte_internal_flags_async.js";import"./svelte/svelte_internal_flags_legacy.js";import"./svelte/svelte_internal_flags_tracing.js";import"./svelte/svelte_internal_server.js";import"./svelte/svelte_legacy.js";import"./svelte/svelte_motion.js";import"./svelte/svelte_reactivity.js";import"./svelte/svelte_reactivity_window.js";import"./svelte/svelte_server.js";import"./svelte/svelte_store.js";import"./svelte/svelte_transition.js";import"./svelte/svelte_events.js";import"./Index-Dqz5Qkzi.js";import"./i18n-CyvX8KmK.js";import"./utils.svelte-Ceck75cM.js";import"./index-tFQomdd2.js";import"./dsv-DB8NKgIY.js";import"./index-CnqicUFC.js";import"./ModifyUpload-2md6CVWe.js";import"./IconButtonWrapper-D4LMIc_2.js";import"./MarkdownCode-C7jLnxqj.js";import"./prism-python-B1e-54E9.js";import"./Index-CjIRSv6a.js";import"./StreamingBar-C6ky6DsM.js";import"./FullscreenButton-CdZP1GYm.js";import"./Example-BRN12iqL.js";function E(e){var n={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:ee(e),edges:ne(e)};return x(e.graph())||(n.value=L(e.graph())),n}function ee(e){return _(e.nodes(),function(n){var t=e.node(n),c=e.parent(n),d={v:n};return x(t)||(d.value=t),x(c)||(d.parent=c),d})}function ne(e){return _(e.edges(),function(n){var t=e.edge(n),c={v:n.v,w:n.w};return x(n.name)||(c.name=n.name),x(t)||(c.value=t),c})}var u=new Map,b=new Map,A=new Map,te=h(()=>{b.clear(),A.clear(),u.clear()},"clear"),O=h((e,n)=>{const t=b.get(n)||[];return i.trace("In isDescendant",n," ",e," = ",t.includes(e)),t.includes(e)},"isDescendant"),ie=h((e,n)=>{const t=b.get(n)||[];return i.info("Descendants of ",n," is ",t),i.info("Edge is ",e),e.v===n||e.w===n?!1:t?t.includes(e.v)||O(e.v,n)||O(e.w,n)||t.includes(e.w):(i.debug("Tilt, ",n,",not in descendants"),!1)},"edgeInCluster"),J=h((e,n,t,c)=>{i.warn("Copying children of ",e,"root",c,"data",n.node(e),c);const d=n.children(e)||[];e!==c&&d.push(e),i.warn("Copying (nodes) clusterId",e,"nodes",d),d.forEach(l=>{if(n.children(l).length>0)J(l,n,t,c);else{const s=n.node(l);i.info("cp ",l," to ",c," with parent ",e),t.setNode(l,s),c!==n.parent(l)&&(i.warn("Setting parent",l,n.parent(l)),t.setParent(l,n.parent(l))),e!==c&&l!==e?(i.debug("Setting parent",l,e),t.setParent(l,e)):(i.info("In copy ",e,"root",c,"data",n.node(e),c),i.debug("Not Setting parent for node=",l,"cluster!==rootId",e!==c,"node!==clusterId",l!==e));const g=n.edges(l);i.debug("Copying Edges",g),g.forEach(a=>{i.info("Edge",a);const v=n.edge(a.v,a.w,a.name);i.info("Edge data",v,c);try{ie(a,c)?(i.info("Copying as ",a.v,a.w,v,a.name),t.setEdge(a.v,a.w,v,a.name),i.info("newGraph edges ",t.edges(),t.edge(t.edges()[0]))):i.info("Skipping copy of edge ",a.v,"-->",a.w," rootId: ",c," clusterId:",e)}catch(S){i.error(S)}})}i.debug("Removing node",l),n.removeNode(l)})},"copy"),G=h((e,n)=>{const t=n.children(e);let c=[...t];for(const d of t)A.set(d,e),c=[...c,...G(d,n)];return c},"extractDescendants"),re=h((e,n,t)=>{const c=e.edges().filter(a=>a.v===n||a.w===n),d=e.edges().filter(a=>a.v===t||a.w===t),l=c.map(a=>({v:a.v===n?t:a.v,w:a.w===n?n:a.w})),s=d.map(a=>({v:a.v,w:a.w}));return l.filter(a=>s.some(v=>a.v===v.v&&a.w===v.w))},"findCommonEdges"),D=h((e,n,t)=>{const c=n.children(e);if(i.trace("Searching children of id ",e,c),c.length<1)return e;let d;for(const l of c){const s=D(l,n,t),g=re(n,t,s);if(s)if(g.length>0)d=s;else return s}return d},"findNonClusterChild"),k=h(e=>!u.has(e)||!u.get(e).externalConnections?e:u.has(e)?u.get(e).id:e,"getAnchorId"),se=h((e,n)=>{if(!e||n>10){i.debug("Opting out, no graph ");return}else i.debug("Opting in, graph ");e.nodes().forEach(function(t){e.children(t).length>0&&(i.warn("Cluster identified",t," Replacement id in edges: ",D(t,e,t)),b.set(t,G(t,e)),u.set(t,{id:D(t,e,t),clusterData:e.node(t)}))}),e.nodes().forEach(function(t){const c=e.children(t),d=e.edges();c.length>0?(i.debug("Cluster identified",t,b),d.forEach(l=>{const s=O(l.v,t),g=O(l.w,t);s^g&&(i.warn("Edge: ",l," leaves cluster ",t),i.warn("Descendants of XXX ",t,": ",b.get(t)),u.get(t).externalConnections=!0)})):i.debug("Not a cluster ",t,b)});for(let t of u.keys()){const c=u.get(t).id,d=e.parent(c);d!==t&&u.has(d)&&!u.get(d).externalConnections&&(u.get(t).id=d)}e.edges().forEach(function(t){const c=e.edge(t);i.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(t)),i.warn("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(e.edge(t)));let d=t.v,l=t.w;if(i.warn("Fix XXX",u,"ids:",t.v,t.w,"Translating: ",u.get(t.v)," --- ",u.get(t.w)),u.get(t.v)||u.get(t.w)){if(i.warn("Fixing and trying - removing XXX",t.v,t.w,t.name),d=k(t.v),l=k(t.w),e.removeEdge(t.v,t.w,t.name),d!==t.v){const s=e.parent(d);u.get(s).externalConnections=!0,c.fromCluster=t.v}if(l!==t.w){const s=e.parent(l);u.get(s).externalConnections=!0,c.toCluster=t.w}i.warn("Fix Replacing with XXX",d,l,t.name),e.setEdge(d,l,c,t.name)}}),i.warn("Adjusted Graph",E(e)),R(e,0),i.trace(u)},"adjustClustersAndEdges"),R=h((e,n)=>{var t,c;if(i.warn("extractor - ",n,E(e),e.children("D")),n>10){i.error("Bailing out");return}let d=e.nodes(),l=!1;for(const s of d){const g=e.children(s);l=l||g.length>0}if(!l){i.debug("Done, no node has children",e.nodes());return}i.debug("Nodes = ",d,n);for(const s of d)if(i.debug("Extracting node",s,u,u.has(s)&&!u.get(s).externalConnections,!e.parent(s),e.node(s),e.children("D")," Depth ",n),!u.has(s))i.debug("Not a cluster",s,n);else if(!u.get(s).externalConnections&&e.children(s)&&e.children(s).length>0){i.warn("Cluster without external connections, without a parent and with children",s,n);let a=e.graph().rankdir==="TB"?"LR":"TB";(c=(t=u.get(s))==null?void 0:t.clusterData)!=null&&c.dir&&(a=u.get(s).clusterData.dir,i.warn("Fixing dir",u.get(s).clusterData.dir,a));const v=new B({multigraph:!0,compound:!0}).setGraph({rankdir:a,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});i.warn("Old graph before copy",E(e)),J(s,e,v,s),e.setNode(s,{clusterNode:!0,id:s,clusterData:u.get(s).clusterData,label:u.get(s).label,graph:v}),i.warn("New graph after copy node: (",s,")",E(v)),i.debug("Old graph after copy",E(e))}else i.warn("Cluster ** ",s," **not meeting the criteria !externalConnections:",!u.get(s).externalConnections," no parent: ",!e.parent(s)," children ",e.children(s)&&e.children(s).length>0,e.children("D"),n),i.debug(u);d=e.nodes(),i.warn("New list of nodes",d);for(const s of d){const g=e.node(s);i.warn(" Now next level",s,g),g?.clusterNode&&R(g.graph,n+1)}},"extractor"),T=h((e,n)=>{if(n.length===0)return[];let t=Object.assign([],n);return n.forEach(c=>{const d=e.children(c),l=T(e,d);t=[...t,...l]}),t},"sorter"),oe=h(e=>T(e,e.children()),"sortNodesByHierarchy"),M=h(async(e,n,t,c,d,l)=>{i.warn("Graph in recursive render:XAX",E(n),d);const s=n.graph().rankdir;i.trace("Dir in recursive render - dir:",s);const g=e.insert("g").attr("class","root");n.nodes()?i.info("Recursive render XXX",n.nodes()):i.info("No nodes found for",n),n.edges().length>0&&i.info("Recursive edges",n.edge(n.edges()[0]));const a=g.insert("g").attr("class","clusters"),v=g.insert("g").attr("class","edgePaths"),S=g.insert("g").attr("class","edgeLabels"),m=g.insert("g").attr("class","nodes");await Promise.all(n.nodes().map(async function(f){const o=n.node(f);if(d!==void 0){const r=JSON.parse(JSON.stringify(d.clusterData));i.trace(`Setting data for parent cluster XXX
 Node.id = `,f,`
 data=`,r.height,`
Parent cluster`,d.height),n.setNode(d.id,r),n.parent(f)||(i.trace("Setting parent",f,d.id),n.setParent(f,d.id,r))}if(i.info("(Insert) Node XXX"+f+": "+JSON.stringify(n.node(f))),o?.clusterNode){i.info("Cluster identified XBX",f,o.width,n.node(f));const{ranksep:r,nodesep:p}=n.graph();o.graph.setGraph({...o.graph.graph(),ranksep:r+25,nodesep:p});const N=await M(m,o.graph,t,c,n.node(f),l),C=N.elem;z(o,C),o.diff=N.diff||0,i.info("New compound node after recursive render XAX",f,"width",o.width,"height",o.height),U(C,o)}else n.children(f).length>0?(i.trace("Cluster - the non recursive path XBX",f,o.id,o,o.width,"Graph:",n),i.trace(D(o.id,n)),u.set(o.id,{id:D(o.id,n),node:o})):(i.trace("Node - the non recursive path XAX",f,m,n.node(f),s),await $(m,n.node(f),{config:l,dir:s}))})),await h(async()=>{const f=n.edges().map(async function(o){const r=n.edge(o.v,o.w,o.name);i.info("Edge "+o.v+" -> "+o.w+": "+JSON.stringify(o)),i.info("Edge "+o.v+" -> "+o.w+": ",o," ",JSON.stringify(n.edge(o))),i.info("Fix",u,"ids:",o.v,o.w,"Translating: ",u.get(o.v),u.get(o.w)),await Z(S,r)});await Promise.all(f)},"processEdges")(),i.info("Graph before layout:",JSON.stringify(E(n))),i.info("############################################# XXX"),i.info("###                Layout                 ### XXX"),i.info("############################################# XXX"),I(n),i.info("Graph after layout:",JSON.stringify(E(n)));let y=0,{subGraphTitleTotalMargin:X}=q(l);return await Promise.all(oe(n).map(async function(f){var o;const r=n.node(f);if(i.info("Position XBX => "+f+": ("+r.x,","+r.y,") width: ",r.width," height: ",r.height),r?.clusterNode)r.y+=X,i.info("A tainted cluster node XBX1",f,r.id,r.width,r.height,r.x,r.y,n.parent(f)),u.get(r.id).node=r,P(r);else if(n.children(f).length>0){i.info("A pure cluster node XBX1",f,r.id,r.x,r.y,r.width,r.height,n.parent(f)),r.height+=X,n.node(r.parentId);const p=r?.padding/2||0,N=((o=r?.labelBBox)==null?void 0:o.height)||0,C=N-p||0;i.debug("OffsetY",C,"labelHeight",N,"halfPadding",p),await K(a,r),u.get(r.id).node=r}else{const p=n.node(r.parentId);r.y+=X/2,i.info("A regular node XBX1 - using the padding",r.id,"parent",r.parentId,r.width,r.height,r.x,r.y,"offsetY",r.offsetY,"parent",p,p?.offsetY,r),P(r)}})),n.edges().forEach(function(f){const o=n.edge(f);i.info("Edge "+f.v+" -> "+f.w+": "+JSON.stringify(o),o),o.points.forEach(C=>C.y+=X/2);const r=n.node(f.v);var p=n.node(f.w);const N=Q(v,o,u,t,r,p,c);W(o,N)}),n.nodes().forEach(function(f){const o=n.node(f);i.info(f,o.type,o.diff),o.isGroup&&(y=o.diff)}),i.warn("Returning from recursive render XAX",g,y),{elem:g,diff:y}},"recursiveRender"),Ue=h(async(e,n)=>{var t,c,d,l,s,g;const a=new B({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((t=e.config)==null?void 0:t.nodeSpacing)||((d=(c=e.config)==null?void 0:c.flowchart)==null?void 0:d.nodeSpacing)||e.nodeSpacing,ranksep:((l=e.config)==null?void 0:l.rankSpacing)||((g=(s=e.config)==null?void 0:s.flowchart)==null?void 0:g.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),v=n.select("g");j(v,e.markers,e.type,e.diagramId),F(),Y(),H(),te(),e.nodes.forEach(m=>{a.setNode(m.id,{...m}),m.parentId&&a.setParent(m.id,m.parentId)}),i.debug("Edges:",e.edges),e.edges.forEach(m=>{if(m.start===m.end){const w=m.start,y=w+"---"+w+"---1",X=w+"---"+w+"---2",f=a.node(w);a.setNode(y,{domId:y,id:y,parentId:f.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),a.setParent(y,f.parentId),a.setNode(X,{domId:X,id:X,parentId:f.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),a.setParent(X,f.parentId);const o=structuredClone(m),r=structuredClone(m),p=structuredClone(m);o.label="",o.arrowTypeEnd="none",o.id=w+"-cyclic-special-1",r.arrowTypeStart="none",r.arrowTypeEnd="none",r.id=w+"-cyclic-special-mid",p.label="",f.isGroup&&(o.fromCluster=w,p.toCluster=w),p.id=w+"-cyclic-special-2",p.arrowTypeStart="none",a.setEdge(w,y,o,w+"-cyclic-special-0"),a.setEdge(y,X,r,w+"-cyclic-special-1"),a.setEdge(X,w,p,w+"-cyc<lic-special-2")}else a.setEdge(m.start,m.end,{...m},m.id)}),i.warn("Graph at first:",JSON.stringify(E(a))),se(a),i.warn("Graph after XAX:",JSON.stringify(E(a)));const S=V();await M(v,a,e.type,e.diagramId,void 0,S)},"render");export{Ue as render};
