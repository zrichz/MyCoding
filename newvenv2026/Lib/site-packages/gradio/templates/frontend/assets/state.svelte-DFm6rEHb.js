import"./svelte/svelte_internal_client.js";class v{current={};fn_outputs={};fn_inputs={};pending_outputs=new Map;fn_status={};show_progress={};register(s,n,t,u){this.fn_outputs[s]=n,this.fn_inputs[s]=t,this.show_progress[s]=u}clear(s){s in this.current&&(this.current[s]={})}update(s){this.resolve_args(s).forEach(({id:t,queue_position:u,queue_size:_,eta:l,status:a,message:o,progress:g,stream_state:c,time_limit:r,type:i})=>{this.current[t]={queue:s.queue||!1,queue_size:_,queue_position:u,eta:l,stream_state:c,message:o,progress:g||void 0,status:a,fn_index:s.fn_index,time_limit:r,type:i,show_progress:this.show_progress[s.fn_index]}})}set_status(s,n){this.current[s].status=n}resolve_args(s){const{fn_index:n,status:t,size:u=void 0,position:_=null,eta:l=null,message:a=null,stream_state:o=null,time_limit:g=null,progress_data:c=null}=s,r=this.fn_outputs[n],i=this.fn_status[n],f=this.fn_inputs[n];return r.concat(f).map(e=>{let p;const d=this.pending_outputs.get(e)||0;if(i==="pending"&&t!=="pending"){let h=d-1;this.pending_outputs.set(e,h<0?0:h),p=h>0?"pending":t}else i==="pending"&&t==="pending"?p="pending":i!=="pending"&&t==="pending"?(p="pending",this.pending_outputs.set(e,d+1)):p=t;const w=f.includes(e)&&o?"input":r.includes(e)?"output":"skip";return{id:e,queue_position:_,queue_size:u,eta:l,status:p,message:a,progress:c,stream_state:o,time_limit:g,type:w}}).filter(e=>e.type!=="skip")}}export{v as L};
