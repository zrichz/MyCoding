import{i as F,F as A,R as c}from"./declarationMapper-qDpwXXCa.js";import{F as w,bh as y,V as j,aq as I,R as _}from"./index-Dtj0WP_z.js";import{F as N}from"./flowGraphCachedOperationBlock-BNmqFgDT.js";import"./index-Dw8Uzof1.js";import"./svelte/svelte_svelte.js";import"./svelte/svelte_animate.js";import"./svelte/svelte_attachments.js";import"./svelte/svelte_easing.js";import"./svelte/svelte_internal_client.js";import"./svelte/svelte_internal_flags_async.js";import"./svelte/svelte_internal_flags_legacy.js";import"./svelte/svelte_internal_flags_tracing.js";import"./svelte/svelte_internal_server.js";import"./svelte/svelte_legacy.js";import"./svelte/svelte_motion.js";import"./svelte/svelte_reactivity.js";import"./svelte/svelte_reactivity_window.js";import"./svelte/svelte_server.js";import"./svelte/svelte_store.js";import"./svelte/svelte_transition.js";import"./svelte/svelte_events.js";import"./KHR_interactivity-BPqRt0iB.js";import"./objectModelMapping-wn7LYZ2M.js";const g=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class V{constructor(r,i){this.path=r,this.ownerBlock=i,this.templatedInputs=[];let n=g.exec(r);const o=new Set;for(;n;){const[,e]=n;if(o.has(e))throw new Error("Duplicate template variable detected.");o.add(e),this.templatedInputs.push(i.registerDataInput(e,F,new A(0))),n=g.exec(r)}}getAccessor(r,i){let n=this.path;for(const o of this.templatedInputs){const e=o.getValue(i).value;if(typeof e!="number"||e<0)throw new Error("Invalid value for templated input.");n=n.replace(`{${o.name}}`,e.toString())}return r.convert(n)}}class D extends N{constructor(r){super(c,r),this.config=r,this.object=this.registerDataOutput("object",c),this.propertyName=this.registerDataOutput("propertyName",c),this.setterFunction=this.registerDataOutput("setFunction",c,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",c,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",c,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new V(r.jsonPointer,this)}_doOperation(r){const i=this.templateComponent.getAccessor(this.config.pathConverter,r),n=i.info.get(i.object),o=i.info.getTarget?.(i.object),e=i.info.getPropertyName?.[0](i.object);if(o)this.object.setValue(o,r),e&&this.propertyName.setValue(e,r);else throw new Error("Object is undefined");return n}_setPropertyValue(r,i,n,o){const e=this.templateComponent.getAccessor(this.config.pathConverter,o),a=e.info.type;a.startsWith("Color")&&(n=C(n,a)),e.info.set?.(n,e.object)}_getPropertyValue(r,i,n){const o=this.templateComponent.getAccessor(this.config.pathConverter,n),e=o.info.type,a=o.info.get(o.object);return e.startsWith("Color")?G(a):a}_getInterpolationAnimationPropertyInfo(r,i,n){const o=this.templateComponent.getAccessor(this.config.pathConverter,n);return(e,a,b,m)=>{const h=[],l=o.info.type;return l.startsWith("Color")&&(e=e.map(p=>({frame:p.frame,value:C(p.value,l)}))),o.info.interpolation?.forEach((p,f)=>{const d=o.info.getPropertyName?.[f](o.object)||"Animation-interpolation-"+f;let u=e;b!==p.type&&(u=e.map(s=>({frame:s.frame,value:p.getValue(void 0,s.value.asArray?s.value.asArray():[s.value],0,1)})));const P=p.buildAnimations(o.object,d,60,u);for(const s of P)m&&s.babylonAnimation.setEasingFunction(m),h.push(s.babylonAnimation)}),h}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function C(t,r){return t.getClassName().startsWith("Color")?t:r==="Color3"?new w(t.x,t.y,t.z):r==="Color4"?new y(t.x,t.y,t.z,t.w):t}function G(t){if(t instanceof w)return new j(t.r,t.g,t.b);if(t instanceof y)return new I(t.r,t.g,t.b,t.a);throw new Error("Invalid color type")}_("FlowGraphJsonPointerParserBlock",D);export{D as FlowGraphJsonPointerParserBlock};
