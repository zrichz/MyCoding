import{O as u,aT as O,aN as p,aO as g}from"./index-Dtj0WP_z.js";import{GLTFLoader as c,ArrayItem as b}from"./glTFLoader-CjRGW40y.js";import"./index-Dw8Uzof1.js";import"./svelte/svelte_svelte.js";import"./svelte/svelte_animate.js";import"./svelte/svelte_attachments.js";import"./svelte/svelte_easing.js";import"./svelte/svelte_internal_client.js";import"./svelte/svelte_internal_flags_async.js";import"./svelte/svelte_internal_flags_legacy.js";import"./svelte/svelte_internal_flags_tracing.js";import"./svelte/svelte_internal_server.js";import"./svelte/svelte_legacy.js";import"./svelte/svelte_motion.js";import"./svelte/svelte_reactivity.js";import"./svelte/svelte_reactivity_window.js";import"./svelte/svelte_server.js";import"./svelte/svelte_store.js";import"./svelte/svelte_transition.js";import"./svelte/svelte_events.js";import"./bone-DTFn1dTu.js";import"./skeleton-GWJYup5v.js";import"./rawTexture-BE3nsnOe.js";import"./assetContainer-BmMhgWSk.js";import"./objectModelMapping-wn7LYZ2M.js";const _="MSFT_lod";class x{constructor(e){this.name=_,this.order=100,this.maxLODsToLoad=10,this.onNodeLODsLoadedObservable=new u,this.onMaterialLODsLoadedObservable=new u,this._bufferLODs=new Array,this._nodeIndexLOD=null,this._nodeSignalLODs=new Array,this._nodePromiseLODs=new Array,this._nodeBufferLODs=new Array,this._materialIndexLOD=null,this._materialSignalLODs=new Array,this._materialPromiseLODs=new Array,this._materialBufferLODs=new Array,this._loader=e,this.maxLODsToLoad=this._loader.parent.extensionOptions[_]?.maxLODsToLoad??this.maxLODsToLoad,this.enabled=this._loader.isExtensionUsed(_)}dispose(){this._loader=null,this._nodeIndexLOD=null,this._nodeSignalLODs.length=0,this._nodePromiseLODs.length=0,this._nodeBufferLODs.length=0,this._materialIndexLOD=null,this._materialSignalLODs.length=0,this._materialPromiseLODs.length=0,this._materialBufferLODs.length=0,this.onMaterialLODsLoadedObservable.clear(),this.onNodeLODsLoadedObservable.clear()}onReady(){for(let e=0;e<this._nodePromiseLODs.length;e++){const i=Promise.all(this._nodePromiseLODs[e]).then(()=>{e!==0&&(this._loader.endPerformanceCounter(`Node LOD ${e}`),this._loader.log(`Loaded node LOD ${e}`)),this.onNodeLODsLoadedObservable.notifyObservers(e),e!==this._nodePromiseLODs.length-1&&(this._loader.startPerformanceCounter(`Node LOD ${e+1}`),this._loadBufferLOD(this._nodeBufferLODs,e+1),this._nodeSignalLODs[e]&&this._nodeSignalLODs[e].resolve())});this._loader._completePromises.push(i)}for(let e=0;e<this._materialPromiseLODs.length;e++){const i=Promise.all(this._materialPromiseLODs[e]).then(()=>{e!==0&&(this._loader.endPerformanceCounter(`Material LOD ${e}`),this._loader.log(`Loaded material LOD ${e}`)),this.onMaterialLODsLoadedObservable.notifyObservers(e),e!==this._materialPromiseLODs.length-1&&(this._loader.startPerformanceCounter(`Material LOD ${e+1}`),this._loadBufferLOD(this._materialBufferLODs,e+1),this._materialSignalLODs[e]&&this._materialSignalLODs[e].resolve())});this._loader._completePromises.push(i)}}loadSceneAsync(e,i){const s=this._loader.loadSceneAsync(e,i);return this._loadBufferLOD(this._bufferLODs,0),s}loadNodeAsync(e,i,s){return c.LoadExtensionAsync(e,i,this.name,async(t,a)=>{let n;const d=this._getLODs(t,i,this._loader.gltf.nodes,a.ids);this._loader.logOpen(`${t}`);for(let o=0;o<d.length;o++){const l=d[o];o!==0&&(this._nodeIndexLOD=o,this._nodeSignalLODs[o]=this._nodeSignalLODs[o]||new O);const r=L=>{s(L),L.setEnabled(!1)},h=this._loader.loadNodeAsync(`/nodes/${l.index}`,l,r).then(L=>{if(o!==0){const m=d[o-1];m._babylonTransformNode&&(this._disposeTransformNode(m._babylonTransformNode),delete m._babylonTransformNode)}return L.setEnabled(!0),L});this._nodePromiseLODs[o]=this._nodePromiseLODs[o]||[],o===0?n=h:(this._nodeIndexLOD=null,this._nodePromiseLODs[o].push(h))}return this._loader.logClose(),await n})}_loadMaterialAsync(e,i,s,t,a){return this._nodeIndexLOD?null:c.LoadExtensionAsync(e,i,this.name,async(n,d)=>{let o;const l=this._getLODs(n,i,this._loader.gltf.materials,d.ids);this._loader.logOpen(`${n}`);for(let r=0;r<l.length;r++){const h=l[r];r!==0&&(this._materialIndexLOD=r);const L=this._loader._loadMaterialAsync(`/materials/${h.index}`,h,s,t,m=>{r===0&&a(m)}).then(m=>{if(r!==0){a(m);const f=l[r-1]._data;f[t]&&(this._disposeMaterials([f[t].babylonMaterial]),delete f[t])}return m});this._materialPromiseLODs[r]=this._materialPromiseLODs[r]||[],r===0?o=L:(this._materialIndexLOD=null,this._materialPromiseLODs[r].push(L))}return this._loader.logClose(),await o})}_loadUriAsync(e,i,s){if(this._nodeIndexLOD!==null){this._loader.log("deferred");const t=this._nodeIndexLOD-1;return this._nodeSignalLODs[t]=this._nodeSignalLODs[t]||new O,this._nodeSignalLODs[this._nodeIndexLOD-1].promise.then(async()=>await this._loader.loadUriAsync(e,i,s))}else if(this._materialIndexLOD!==null){this._loader.log("deferred");const t=this._materialIndexLOD-1;return this._materialSignalLODs[t]=this._materialSignalLODs[t]||new O,this._materialSignalLODs[t].promise.then(async()=>await this._loader.loadUriAsync(e,i,s))}return null}loadBufferAsync(e,i,s,t){if(this._loader.parent.useRangeRequests&&!i.uri){if(!this._loader.bin)throw new Error(`${e}: Uri is missing or the binary glTF is missing its binary chunk`);const a=async(n,d)=>{const o=s,l=o+t-1;let r=n[d];return r?(r.start=Math.min(r.start,o),r.end=Math.max(r.end,l)):(r={start:o,end:l,loaded:new O},n[d]=r),await r.loaded.promise.then(h=>new Uint8Array(h.buffer,h.byteOffset+s-r.start,t))};return this._loader.log("deferred"),this._nodeIndexLOD!==null?a(this._nodeBufferLODs,this._nodeIndexLOD):this._materialIndexLOD!==null?a(this._materialBufferLODs,this._materialIndexLOD):a(this._bufferLODs,0)}return null}_loadBufferLOD(e,i){const s=e[i];s&&(this._loader.log(`Loading buffer range [${s.start}-${s.end}]`),this._loader.bin.readAsync(s.start,s.end-s.start+1).then(t=>{s.loaded.resolve(t)},t=>{s.loaded.reject(t)}))}_getLODs(e,i,s,t){if(this.maxLODsToLoad<=0)throw new Error("maxLODsToLoad must be greater than zero");const a=[];for(let n=t.length-1;n>=0;n--)if(a.push(b.Get(`${e}/ids/${t[n]}`,s,t[n])),a.length===this.maxLODsToLoad)return a;return a.push(i),a}_disposeTransformNode(e){const i=[],s=e.material;s&&i.push(s);for(const a of e.getChildMeshes())a.material&&i.push(a.material);e.dispose();const t=i.filter(a=>this._loader.babylonScene.meshes.every(n=>n.material!=a));this._disposeMaterials(t)}_disposeMaterials(e){const i={};for(const s of e){for(const t of s.getActiveTextures())i[t.uniqueId]=t;s.dispose()}for(const s in i)for(const t of this._loader.babylonScene.materials)t.hasTexture(i[s])&&delete i[s];for(const s in i)i[s].dispose()}}p(_);g(_,!0,D=>new x(D));export{x as MSFT_lod};
