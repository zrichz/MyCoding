import{az as p,V as E,M as h,e as Y,Q as R,b9 as g,aE as U}from"./index-Dtj0WP_z.js";import{A as b}from"./assetContainer-BmMhgWSk.js";import{B as V}from"./bone-DTFn1dTu.js";import{S as D}from"./skeleton-GWJYup5v.js";import"./index-Dw8Uzof1.js";import"./svelte/svelte_svelte.js";import"./svelte/svelte_animate.js";import"./svelte/svelte_attachments.js";import"./svelte/svelte_easing.js";import"./svelte/svelte_internal_client.js";import"./svelte/svelte_internal_flags_async.js";import"./svelte/svelte_internal_flags_legacy.js";import"./svelte/svelte_internal_flags_tracing.js";import"./svelte/svelte_internal_server.js";import"./svelte/svelte_legacy.js";import"./svelte/svelte_motion.js";import"./svelte/svelte_reactivity.js";import"./svelte/svelte_reactivity_window.js";import"./svelte/svelte_server.js";import"./svelte/svelte_store.js";import"./svelte/svelte_transition.js";import"./svelte/svelte_events.js";import"./rawTexture-BE3nsnOe.js";const O="Xposition",F="Yposition",k="Zposition",x="Xrotation",M="Yrotation",v="Zrotation",j="HIERARCHY",K="MOTION";class z{constructor(t){this.loopMode=p.ANIMATIONLOOPMODE_CYCLE,this.list=[],this.root=_(),this.numFrames=0,this.frameRate=0,this.skeleton=t}}function _(){return{name:"",type:"",offset:new E,channels:[],children:[],frames:[],parent:null}}function X(){return{frame:0,position:new E,rotation:new R}}function Z(r){const t=r.offset.x,o=r.offset.y,s=r.offset.z;return h.Translation(t,o,s)}function Q(r,t){if(r.frames.length===0)return[];const o=[],s=r.channels.some(f=>f===O||f===F||f===k),e=r.channels.some(f=>f===x||f===M||f===v),n=new p(`${r.name}_pos`,"position",t.frameRate,p.ANIMATIONTYPE_VECTOR3,t.loopMode),a=new p(`${r.name}_rot`,"rotationQuaternion",t.frameRate,p.ANIMATIONTYPE_QUATERNION,t.loopMode),i=[],l=[];for(let f=0;f<r.frames.length;f++){const c=r.frames[f];s&&c.position&&i.push({frame:c.frame,value:c.position.clone()}),e&&l.push({frame:c.frame,value:c.rotation.clone()})}return i.length>0&&(n.setKeys(i),o.push(n)),l.length>0&&(a.setKeys(l),o.push(a)),o}function P(r,t,o){const s=Z(r),e=new V(r.name,o.skeleton,t,s),n=Q(r,o);for(const a of n)a.getKeys()&&a.getKeys().length>0&&e.animations.push(a);for(const a of r.children)P(a,e,o)}function B(r,t,o,s){if(o.type==="ENDSITE")return;const e=X();e.frame=t,e.position=new E,e.rotation=new R,o.frames.push(e);let n=h.Identity();for(let a=0;a<o.channels.length;++a){const i=o.channels[a],l=r[s.i++];if(!l)continue;const f=parseFloat(l.trim());if(i.endsWith("position"))switch(i){case O:e.position.x=f;break;case F:e.position.y=f;break;case k:e.position.z=f;break}else if(i.endsWith("rotation")){const c=Y.ToRadians(f);let m;switch(i){case x:m=h.RotationX(c);break;case M:m=h.RotationY(c);break;case v:m=h.RotationZ(c);break}n=m.multiply(n)}}R.FromRotationMatrixToRef(n,e.rotation);for(const a of o.children)B(r,t,a,s)}function L(r,t,o,s){const e=_();e.parent=o,s.list.push(e);let n=t.trim().split(/\s+/);if(n[0].toUpperCase()==="END"&&n[1].toUpperCase()==="SITE"?(e.type="ENDSITE",e.name="ENDSITE"):(e.name=n[1],e.type=n[0].toUpperCase()),r.shift()?.trim()!="{")throw new Error("Expected opening { after type & name");const a=r.shift()?.trim().split(/\s+/);if(!a)throw new Error("Unexpected end of file: missing OFFSET");if(n=a,n[0].toUpperCase()!="OFFSET")throw new Error("Expected OFFSET, but got: "+n[0]);if(n.length!=4)throw new Error("OFFSET: Invalid number of values");const i=new E(parseFloat(n[1]),parseFloat(n[2]),parseFloat(n[3]));if(isNaN(i.x)||isNaN(i.y)||isNaN(i.z))throw new Error("OFFSET: Invalid values");if(e.offset=i,e.type!="ENDSITE"){if(n=r.shift()?.trim().split(/\s+/),!n)throw new Error("Unexpected end of file: missing CHANNELS");if(n[0].toUpperCase()!="CHANNELS")throw new Error("Expected CHANNELS definition");const l=parseInt(n[1]);e.channels=n.splice(2,l),e.children=[]}for(;r.length>0;){const l=r.shift()?.trim();if(l==="}")return e;l&&e.children.push(L(r,l,e,s))}throw new Error("Unexpected end of file: missing closing brace")}function T(r,t,o,s){const e=r.split(`
`),{loopMode:n}=s;t._blockEntityCollection=!!o;const a=new D("","",t);a._parentContainer=o,t._blockEntityCollection=!1;const i=new z(a);i.loopMode=n;const l=e.shift();if(!l||l.trim().toUpperCase()!==j)throw new Error("HIERARCHY expected");const f=e.shift();if(!f)throw new Error("Unexpected end of file after HIERARCHY");const c=L(e,f.trim(),null,i),m=e.shift();if(!m||m.trim().toUpperCase()!==K)throw new Error("MOTION expected");const y=e.shift();if(!y)throw new Error("Unexpected end of file before frame count");const C=y.trim().split(/[\s]+/);if(C.length<2)throw new Error("Invalid frame count line");const w=parseInt(C[1]);if(isNaN(w))throw new Error("Failed to read number of frames.");i.numFrames=w;const H=e.shift();if(!H)throw new Error("Unexpected end of file before frame time");const A=H.trim().split(/[\s]+/);if(A.length<3)throw new Error("Invalid frame time line");const u=parseFloat(A[2]);if(isNaN(u))throw new Error("Failed to read frame time.");if(u<=0)throw new Error("Failed to read frame time. Invalid value "+u);i.frameRate=1/u;for(let N=0;N<w;++N){const I=e.shift();if(!I)continue;const S=I.trim().split(/[\s]+/)||[];B(S,N,c,{i:0})}return i.root=c,P(i.root,null,i),i.skeleton.returnToRest(),i.skeleton}class d{constructor(t){this.name=g.name,this.extensions=g.extensions,this._loadingOptions={...d._DefaultLoadingOptions,...t??{}}}static get _DefaultLoadingOptions(){return{loopMode:p.ANIMATIONLOOPMODE_CYCLE}}createPlugin(t){return new d(t[g.name])}canDirectLoad(t){return this.isBvhHeader(t)}isBvhHeader(t){return t.split(`
`)[0]=="HIERARCHY"}isNotBvhHeader(t){return!this.isBvhHeader(t)}importMeshAsync(t,o,s){if(typeof s!="string")return Promise.reject("BVH loader expects string data.");if(this.isNotBvhHeader(s))return Promise.reject("BVH loader expects HIERARCHY header.");try{const e=T(s,o,null,this._loadingOptions);return Promise.resolve({meshes:[],particleSystems:[],skeletons:[e],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]})}catch(e){return Promise.reject(e)}}loadAsync(t,o){return typeof o!="string"?Promise.reject("BVH loader expects string data."):this.isNotBvhHeader(o)?Promise.reject("BVH loader expects HIERARCHY header."):this.importMeshAsync(null,t,o).then(()=>{})}loadAssetContainerAsync(t,o){if(typeof o!="string")return Promise.reject("BVH loader expects string data.");if(this.isNotBvhHeader(o))return Promise.reject("BVH loader expects HIERARCHY header.");const s=new b(t);try{const e=T(o,t,s,this._loadingOptions);return s.skeletons.push(e),Promise.resolve(s)}catch(e){return Promise.reject(e)}}}U(new d);export{d as BVHFileLoader};
