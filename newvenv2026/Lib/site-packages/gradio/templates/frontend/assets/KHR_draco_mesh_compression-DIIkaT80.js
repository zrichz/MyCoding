import{e as A,bm as M,m as _,L as v,aN as V,aO as k}from"./index-Dtj0WP_z.js";import{A as R}from"./workerPool-CfMXSLnf.js";import{GLTFLoader as F,ArrayItem as D,LoadBoundingInfoFromPositionAccessor as N}from"./glTFLoader-CjRGW40y.js";import"./index-Dw8Uzof1.js";import"./svelte/svelte_svelte.js";import"./svelte/svelte_animate.js";import"./svelte/svelte_attachments.js";import"./svelte/svelte_easing.js";import"./svelte/svelte_internal_client.js";import"./svelte/svelte_internal_flags_async.js";import"./svelte/svelte_internal_flags_legacy.js";import"./svelte/svelte_internal_flags_tracing.js";import"./svelte/svelte_internal_server.js";import"./svelte/svelte_legacy.js";import"./svelte/svelte_motion.js";import"./svelte/svelte_reactivity.js";import"./svelte/svelte_reactivity_window.js";import"./svelte/svelte_server.js";import"./svelte/svelte_store.js";import"./svelte/svelte_transition.js";import"./svelte/svelte_events.js";import"./bone-DTFn1dTu.js";import"./skeleton-GWJYup5v.js";import"./rawTexture-BE3nsnOe.js";import"./assetContainer-BmMhgWSk.js";import"./objectModelMapping-wn7LYZ2M.js";function I(c,t,n,i,f){const e=c;let r=null,o=null,s=null;try{r=new e.Decoder,o=new e.DecoderBuffer,o.Init(t,t.byteLength);let a;const l=r.GetEncodedGeometryType(o);switch(l){case e.TRIANGULAR_MESH:{const d=new e.Mesh;if(a=r.DecodeBufferToMesh(o,d),!a.ok()||d.ptr===0)throw new Error(a.error_msg());const y=d.num_faces()*3,p=y*4,u=e._malloc(p);try{r.GetTrianglesUInt32Array(d,p,u);const P=new Uint32Array(y);P.set(new Uint32Array(e.HEAPF32.buffer,u,y)),i(P)}finally{e._free(u)}s=d;break}case e.POINT_CLOUD:{const d=new e.PointCloud;if(a=r.DecodeBufferToPointCloud(o,d),!a.ok()||!d.ptr)throw new Error(a.error_msg());s=d;break}default:throw new Error(`Invalid geometry type ${l}`)}const h=s.num_points(),b=(d,m,y,p)=>{const u=p.data_type(),P=p.num_components(),O=p.normalized(),B=p.byte_stride(),C=p.byte_offset(),T={[e.DT_FLOAT32]:{typedArrayConstructor:Float32Array,heap:e.HEAPF32},[e.DT_INT8]:{typedArrayConstructor:Int8Array,heap:e.HEAP8},[e.DT_INT16]:{typedArrayConstructor:Int16Array,heap:e.HEAP16},[e.DT_INT32]:{typedArrayConstructor:Int32Array,heap:e.HEAP32},[e.DT_UINT8]:{typedArrayConstructor:Uint8Array,heap:e.HEAPU8},[e.DT_UINT16]:{typedArrayConstructor:Uint16Array,heap:e.HEAPU16},[e.DT_UINT32]:{typedArrayConstructor:Uint32Array,heap:e.HEAPU32}}[u];if(!T)throw new Error(`Invalid data type ${u}`);const U=h*P,L=U*T.typedArrayConstructor.BYTES_PER_ELEMENT,g=e._malloc(L);try{d.GetAttributeDataArrayForAllPoints(m,p,u,L,g);const G=new T.typedArrayConstructor(T.heap.buffer,g,U);f(y,G.slice(),P,C,B,O)}finally{e._free(g)}};if(n)for(const d in n){const m=n[d],y=r.GetAttributeByUniqueId(s,m);b(r,s,d,y)}else{const d={position:e.POSITION,normal:e.NORMAL,color:e.COLOR,uv:e.TEX_COORD};for(const m in d){const y=r.GetAttributeId(s,d[m]);if(y!==-1){const p=r.GetAttribute(s,y);b(r,s,m,p)}}}return h}finally{s&&e.destroy(s),o&&e.destroy(o),r&&e.destroy(r)}}function S(){let c;onmessage=t=>{const n=t.data;switch(n.id){case"init":{n.url&&importScripts(n.url);const i=n.wasmBinary?{wasmBinary:n.wasmBinary}:{};c=DracoDecoderModule(i),postMessage({id:"initDone"});break}case"decodeMesh":{if(!c)throw new Error("Draco decoder module is not available");c.then(i=>{const f=I(i,n.dataView,n.attributes,e=>{postMessage({id:"indices",data:e},[e.buffer])},(e,r,o,s,a,l)=>{postMessage({id:"attribute",kind:e,data:r,size:o,byteOffset:s,byteStride:a,normalized:l},[r.buffer])});postMessage({id:"decodeMeshDone",totalVertices:f})});break}}}}async function W(c,t,n){return await new Promise((i,f)=>{const e=o=>{c.removeEventListener("error",e),c.removeEventListener("message",r),f(o)},r=o=>{o.data.id==="initDone"&&(c.removeEventListener("error",e),c.removeEventListener("message",r),i(c))};if(c.addEventListener("error",e),c.addEventListener("message",r),!t)c.postMessage({id:"init",url:n});else{const o=t.slice(0);c.postMessage({id:"init",url:n,wasmBinary:o},[o])}})}function K(){return typeof navigator!="object"||!navigator.hardwareConcurrency?1:Math.min(Math.floor(navigator.hardwareConcurrency*.5),4)}function $(c){return!!(c.wasmUrl&&(c.wasmBinary||c.wasmBinaryUrl)&&typeof WebAssembly=="object"||c.fallbackUrl)}class z{constructor(t){if(t.workerPool){this._workerPoolPromise=Promise.resolve(t.workerPool);return}const n=t.wasmBinary,i=t.numWorkers??K(),f=i&&typeof Worker=="function"&&typeof URL=="function",e=f||!t.jsModule,r=t.wasmUrl&&t.wasmBinaryUrl&&typeof WebAssembly=="object"?{url:e?A.GetBabylonScriptURL(t.wasmUrl,!0):"",wasmBinaryPromise:n?Promise.resolve(n):A.LoadFileAsync(A.GetBabylonScriptURL(t.wasmBinaryUrl,!0))}:{url:e?A.GetBabylonScriptURL(t.fallbackUrl):"",wasmBinaryPromise:Promise.resolve(void 0)};f?this._workerPoolPromise=r.wasmBinaryPromise.then(o=>{const s=this._getWorkerContent(),a=URL.createObjectURL(new Blob([s],{type:"application/javascript"}));return new R(i,()=>{const l=new Worker(a);return W(l,o,r.url)})}):this._modulePromise=r.wasmBinaryPromise.then(async o=>{if(!this._isModuleAvailable()&&!t.jsModule){if(!r.url)throw new Error("Draco codec module is not available");await A.LoadBabylonScriptAsync(r.url)}return await this._createModuleAsync(o,t.jsModule)})}async whenReadyAsync(){if(this._workerPoolPromise){await this._workerPoolPromise;return}if(this._modulePromise){await this._modulePromise;return}}dispose(){this._workerPoolPromise&&this._workerPoolPromise.then(t=>{t.dispose()}),delete this._workerPoolPromise,delete this._modulePromise}}class w extends z{static get DefaultAvailable(){return $(w.DefaultConfiguration)}static get Default(){return w._Default??(w._Default=new w),w._Default}static ResetDefault(t){w._Default&&(t||w._Default.dispose(),w._Default=null)}_isModuleAvailable(){return typeof DracoDecoderModule<"u"}async _createModuleAsync(t,n){return{module:await(n||DracoDecoderModule)({wasmBinary:t})}}_getWorkerContent(){return`${I}(${S})()`}constructor(t=w.DefaultConfiguration){super(t)}decodeMeshToMeshDataAsync(t,n,i){const f=t instanceof ArrayBuffer?new Int8Array(t):new Int8Array(t.buffer,t.byteOffset,t.byteLength),e=(r,o)=>i&&i[r]!==void 0?(o!==i[r]&&v.Warn(`Normalized flag from Draco data (${o}) does not match normalized flag from glTF accessor (${i[r]}). Using flag from glTF accessor.`),i[r]):o;if(this._workerPoolPromise)return this._workerPoolPromise.then(async r=>await new Promise((o,s)=>{r.push((a,l)=>{let h=null;const b=[],d=p=>{a.removeEventListener("error",d),a.removeEventListener("message",m),s(p),l()},m=p=>{const u=p.data;switch(u.id){case"indices":{h=u.data;break}case"attribute":{b.push({kind:u.kind,data:u.data,size:u.size,byteOffset:u.byteOffset,byteStride:u.byteStride,normalized:e(u.kind,u.normalized)});break}case"decodeMeshDone":{a.removeEventListener("error",d),a.removeEventListener("message",m),o({indices:h,attributes:b,totalVertices:u.totalVertices}),l();break}}};a.addEventListener("error",d),a.addEventListener("message",m);const y=f.slice();a.postMessage({id:"decodeMesh",dataView:y,attributes:n},[y.buffer])})}));if(this._modulePromise)return this._modulePromise.then(r=>{let o=null;const s=[],a=I(r.module,f,n,l=>{o=l},(l,h,b,d,m,y)=>{s.push({kind:l,data:h,size:b,byteOffset:d,byteStride:m,normalized:y})});return{indices:o,attributes:s,totalVertices:a}});throw new Error("Draco decoder module is not available")}async decodeMeshToGeometryAsync(t,n,i,f){const e=await this.decodeMeshToMeshDataAsync(i,f),r=new M(t,n);e.indices&&r.setIndices(e.indices);for(const o of e.attributes)r.setVerticesBuffer(new _(n.getEngine(),o.data,o.kind,!1,void 0,o.byteStride,void 0,o.byteOffset,o.size,void 0,o.normalized,!0),e.totalVertices);return r}async _decodeMeshToGeometryForGltfAsync(t,n,i,f,e,r){const o=await this.decodeMeshToMeshDataAsync(i,f,e),s=new M(t,n);r&&(s._boundingInfo=r,s.useBoundingInfoFromGeometry=!0),o.indices&&s.setIndices(o.indices);for(const a of o.attributes)s.setVerticesBuffer(new _(n.getEngine(),a.data,a.kind,!1,void 0,a.byteStride,void 0,a.byteOffset,a.size,void 0,a.normalized,!0),o.totalVertices);return s}}w.DefaultConfiguration={wasmUrl:`${A._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,wasmBinaryUrl:`${A._DefaultCdnUrl}/draco_decoder_gltf.wasm`,fallbackUrl:`${A._DefaultCdnUrl}/draco_decoder_gltf.js`};w._Default=null;const E="KHR_draco_mesh_compression";class H{constructor(t){this.name=E,this.useNormalizedFlagFromAccessor=!0,this._loader=t,this.enabled=w.DefaultAvailable&&this._loader.isExtensionUsed(E)}dispose(){delete this.dracoDecoder,this._loader=null}_loadVertexDataAsync(t,n,i){return F.LoadExtensionAsync(t,n,this.name,async(f,e)=>{if(n.mode!=null&&n.mode!==4&&n.mode!==5)throw new Error(`${t}: Unsupported mode ${n.mode}`);const r={},o={},s=(l,h)=>{const b=e.attributes[l];if(b!=null&&(i._delayInfo=i._delayInfo||[],i._delayInfo.indexOf(h)===-1&&i._delayInfo.push(h),r[h]=b,this.useNormalizedFlagFromAccessor)){const d=D.TryGet(this._loader.gltf.accessors,n.attributes[l]);d&&(o[h]=d.normalized||!1)}};s("POSITION",_.PositionKind),s("NORMAL",_.NormalKind),s("TANGENT",_.TangentKind),s("TEXCOORD_0",_.UVKind),s("TEXCOORD_1",_.UV2Kind),s("TEXCOORD_2",_.UV3Kind),s("TEXCOORD_3",_.UV4Kind),s("TEXCOORD_4",_.UV5Kind),s("TEXCOORD_5",_.UV6Kind),s("JOINTS_0",_.MatricesIndicesKind),s("WEIGHTS_0",_.MatricesWeightsKind),s("COLOR_0",_.ColorKind);const a=D.Get(f,this._loader.gltf.bufferViews,e.bufferView);return a._dracoBabylonGeometry||(a._dracoBabylonGeometry=this._loader.loadBufferViewAsync(`/bufferViews/${a.index}`,a).then(async l=>{const h=this.dracoDecoder||w.Default,b=D.TryGet(this._loader.gltf.accessors,n.attributes.POSITION),d=!this._loader.parent.alwaysComputeBoundingBox&&!i.skeleton&&b?N(b):null;return await h._decodeMeshToGeometryForGltfAsync(i.name,this._loader.babylonScene,l,r,o,d).catch(m=>{throw new Error(`${t}: ${m.message}`)})})),await a._dracoBabylonGeometry})}}V(E);k(E,!0,c=>new H(c));export{H as KHR_draco_mesh_compression};
