const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./hdrFiltering.vertex-tIqOopXx.js","./index-Dtj0WP_z.js","./index-Dw8Uzof1.js","./index-qRhMeKhs.css","./hdrFiltering.fragment-DpktMng8.js","./helperFunctions-Cj61g9Q2.js","./hdrFilteringFunctions-CECi4QTM.js","./pbrBRDFFunctions-XImUPJn1.js","./hdrFiltering.vertex-CWw8r7r0.js","./hdrFiltering.fragment-BGzLjQWh.js","./helperFunctions-vhBENDhA.js","./hdrFilteringFunctions-D-5zE1ac.js","./pbrBRDFFunctions-CP_oLCua.js","./hdrIrradianceFiltering.vertex-_DIjZ3Ga.js","./hdrIrradianceFiltering.fragment-DV1YK6HR.js","./hdrIrradianceFiltering.vertex-3pS_rKbO.js","./hdrIrradianceFiltering.fragment-CWVOp4-X.js"])))=>i.map(i=>d[i]);
import{aG as M,V as i,aL as R,aK as F,B as I,M as T,O as L,a as A,e as P,aW as v,bo as x,aV as y,R as E}from"./index-Dtj0WP_z.js";import{_ as p}from"./index-Dw8Uzof1.js";import{I as W}from"./iblCdfGenerator-CFRZO3nP.js";import{G as D}from"./hdr-CfWvLTFH.js";import"./svelte/svelte_svelte.js";import"./svelte/svelte_animate.js";import"./svelte/svelte_attachments.js";import"./svelte/svelte_easing.js";import"./svelte/svelte_internal_client.js";import"./svelte/svelte_internal_flags_async.js";import"./svelte/svelte_internal_flags_legacy.js";import"./svelte/svelte_internal_flags_tracing.js";import"./svelte/svelte_internal_server.js";import"./svelte/svelte_legacy.js";import"./svelte/svelte_motion.js";import"./svelte/svelte_reactivity.js";import"./svelte/svelte_reactivity_window.js";import"./svelte/svelte_server.js";import"./svelte/svelte_store.js";import"./svelte/svelte_transition.js";import"./svelte/svelte_events.js";import"./rawTexture-BE3nsnOe.js";class G{constructor(e,t={}){this._lodGenerationOffset=0,this._lodGenerationScale=.8,this.quality=4096,this.hdrScale=1,this._engine=e,this.hdrScale=t.hdrScale||this.hdrScale,this.quality=t.quality||this.quality}_createRenderTarget(e){let t=0;this._engine.getCaps().textureHalfFloatRender?t=2:this._engine.getCaps().textureFloatRender&&(t=1);const r=this._engine.createRenderTargetCubeTexture(e,{format:5,type:t,createMipMaps:!0,generateMipMaps:!1,generateDepthBuffer:!1,generateStencilBuffer:!1,samplingMode:1,label:"HDR_Radiance_Filtering_Target"});return this._engine.updateTextureWrappingMode(r.texture,0,0,0),this._engine.updateTextureSamplingMode(3,r.texture,!0),r}_prefilterInternal(e){const t=e.getSize().width,r=M(t)+1,a=this._effectWrapper.effect,h=this._createRenderTarget(t);this._effectRenderer.saveStates(),this._effectRenderer.setViewport();const d=e.getInternalTexture();d&&this._engine.updateTextureSamplingMode(3,d,!0),this._effectRenderer.applyEffectWrapper(this._effectWrapper);const f=[[new i(0,0,-1),new i(0,-1,0),new i(1,0,0)],[new i(0,0,1),new i(0,-1,0),new i(-1,0,0)],[new i(1,0,0),new i(0,0,1),new i(0,1,0)],[new i(1,0,0),new i(0,0,-1),new i(0,-1,0)],[new i(1,0,0),new i(0,-1,0),new i(0,0,1)],[new i(-1,0,0),new i(0,-1,0),new i(0,0,-1)]];a.setFloat("hdrScale",this.hdrScale),a.setFloat2("vFilteringInfo",e.getSize().width,r),a.setTexture("inputTexture",e);for(let c=0;c<6;c++){a.setVector3("up",f[c][0]),a.setVector3("right",f[c][1]),a.setVector3("front",f[c][2]);for(let s=0;s<r;s++){this._engine.bindFramebuffer(h,c,void 0,void 0,!0,s),this._effectRenderer.applyEffectWrapper(this._effectWrapper);let n=Math.pow(2,(s-this._lodGenerationOffset)/this._lodGenerationScale)/t;s===0&&(n=0),a.setFloat("alphaG",n),this._effectRenderer.draw()}}this._effectRenderer.restoreStates(),this._engine.restoreDefaultFramebuffer(),this._engine._releaseTexture(e._texture);const l=h.texture.type,o=h.texture.format;return h._swapAndDie(e._texture),e._texture.type=l,e._texture.format=o,e.gammaSpace=!1,e.lodGenerationOffset=this._lodGenerationOffset,e.lodGenerationScale=this._lodGenerationScale,e._prefiltered=!0,e}_createEffect(e,t){const r=[];e.gammaSpace&&r.push("#define GAMMA_INPUT"),r.push("#define NUM_SAMPLES "+this.quality+"u");const a=this._engine.isWebGPU;return new R({engine:this._engine,name:"hdrFiltering",vertexShader:"hdrFiltering",fragmentShader:"hdrFiltering",samplerNames:["inputTexture"],uniformNames:["vSampleDirections","vWeights","up","right","front","vFilteringInfo","hdrScale","alphaG"],useShaderStore:!0,defines:r,onCompiled:t,shaderLanguage:a?1:0,extraInitializationsAsync:async()=>{a?await Promise.all([p(()=>import("./hdrFiltering.vertex-tIqOopXx.js"),__vite__mapDeps([0,1,2,3]),import.meta.url),p(()=>import("./hdrFiltering.fragment-DpktMng8.js"),__vite__mapDeps([4,1,2,3,5,6,7]),import.meta.url)]):await Promise.all([p(()=>import("./hdrFiltering.vertex-CWw8r7r0.js"),__vite__mapDeps([8,1,2,3]),import.meta.url),p(()=>import("./hdrFiltering.fragment-BGzLjQWh.js"),__vite__mapDeps([9,1,2,3,10,11,12]),import.meta.url)])}})}isReady(e){return e.isReady()&&this._effectWrapper.effect.isReady()}async prefilter(e){if(!this._engine._features.allowTexturePrefiltering)throw new Error("HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.");this._effectRenderer=new F(this._engine),this._effectWrapper=this._createEffect(e),await this._effectWrapper.effect.whenCompiledAsync(),this._prefilterInternal(e),this._effectRenderer.dispose(),this._effectWrapper.dispose()}}class z{constructor(e,t={}){this.quality=4096,this.hdrScale=1,this.useCdf=!1,this._engine=e,this.hdrScale=t.hdrScale||this.hdrScale,this.quality=t.quality||this.quality,this.useCdf=t.useCdf||this.useCdf}_createRenderTarget(e){let t=0;this._engine.getCaps().textureHalfFloatRender?t=2:this._engine.getCaps().textureFloatRender&&(t=1);const r=this._engine.createRenderTargetCubeTexture(e,{format:5,type:t,createMipMaps:!1,generateMipMaps:!1,generateDepthBuffer:!1,generateStencilBuffer:!1,samplingMode:2,label:"HDR_Irradiance_Filtering_Target"});return this._engine.updateTextureWrappingMode(r.texture,0,0,0),r}_prefilterInternal(e){const t=e.getSize().width,r=M(t),a=this._effectWrapper.effect,h=Math.max(32,1<<M(t>>3)),d=this._createRenderTarget(h);this._effectRenderer.saveStates(),this._effectRenderer.setViewport(),this._effectRenderer.applyEffectWrapper(this._effectWrapper);const f=[[new i(0,0,-1),new i(0,-1,0),new i(1,0,0)],[new i(0,0,1),new i(0,-1,0),new i(-1,0,0)],[new i(1,0,0),new i(0,0,1),new i(0,1,0)],[new i(1,0,0),new i(0,0,-1),new i(0,-1,0)],[new i(1,0,0),new i(0,-1,0),new i(0,0,1)],[new i(-1,0,0),new i(0,-1,0),new i(0,0,-1)]];a.setFloat("hdrScale",this.hdrScale),a.setFloat2("vFilteringInfo",e.getSize().width,r),a.setTexture("inputTexture",e),this._cdfGenerator&&a.setTexture("icdfTexture",this._cdfGenerator.getIcdfTexture());for(let o=0;o<6;o++)a.setVector3("up",f[o][0]),a.setVector3("right",f[o][1]),a.setVector3("front",f[o][2]),this._engine.bindFramebuffer(d,o,void 0,void 0,!0),this._effectRenderer.applyEffectWrapper(this._effectWrapper),this._effectRenderer.draw();this._effectRenderer.restoreStates(),this._engine.restoreDefaultFramebuffer(),a.setTexture("inputTexture",null),a.setTexture("icdfTexture",null);const l=new I(e.getScene(),d.texture);return l.name=e.name+"_irradiance",l.displayName=e.name+"_irradiance",l.gammaSpace=!1,l}_createEffect(e,t){const r=[];e.gammaSpace&&r.push("#define GAMMA_INPUT"),r.push("#define NUM_SAMPLES "+this.quality+"u");const a=this._engine.isWebGPU,h=["inputTexture"];return this._cdfGenerator&&(h.push("icdfTexture"),r.push("#define IBL_CDF_FILTERING")),new R({engine:this._engine,name:"HDRIrradianceFiltering",vertexShader:"hdrIrradianceFiltering",fragmentShader:"hdrIrradianceFiltering",samplerNames:h,uniformNames:["vSampleDirections","vWeights","up","right","front","vFilteringInfo","hdrScale"],useShaderStore:!0,defines:r,onCompiled:t,shaderLanguage:a?1:0,extraInitializationsAsync:async()=>{a?await Promise.all([p(()=>import("./hdrIrradianceFiltering.vertex-_DIjZ3Ga.js"),__vite__mapDeps([13,1,2,3]),import.meta.url),p(()=>import("./hdrIrradianceFiltering.fragment-DV1YK6HR.js"),__vite__mapDeps([14,1,2,3,5,6,7]),import.meta.url)]):await Promise.all([p(()=>import("./hdrIrradianceFiltering.vertex-3pS_rKbO.js"),__vite__mapDeps([15,1,2,3]),import.meta.url),p(()=>import("./hdrIrradianceFiltering.fragment-CWVOp4-X.js"),__vite__mapDeps([16,1,2,3,10,11,12]),import.meta.url)])}})}isReady(e){return e.isReady()&&this._effectWrapper.effect.isReady()}async prefilter(e){if(!this._engine._features.allowTexturePrefiltering)throw new Error("HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.");this.useCdf&&(this._cdfGenerator=new W(this._engine),this._cdfGenerator.iblSource=e,await this._cdfGenerator.renderWhenReady()),this._effectRenderer=new F(this._engine),this._effectWrapper=this._createEffect(e),await this._effectWrapper.effect.whenCompiledAsync();const t=this._prefilterInternal(e);return this.useCdf&&await this._cdfGenerator.findDominantDirection().then(r=>{t._dominantDirection=r}),this._effectRenderer.dispose(),this._effectWrapper.dispose(),this._cdfGenerator?.dispose(),t}}class _ extends I{set isBlocking(e){this._isBlocking=e}get isBlocking(){return this._isBlocking}set rotationY(e){this._rotationY=e,this.setReflectionTextureMatrix(T.RotationY(this._rotationY))}get rotationY(){return this._rotationY}set boundingBoxSize(e){if(this._boundingBoxSize&&this._boundingBoxSize.equals(e))return;this._boundingBoxSize=e;const t=this.getScene();t&&t.markAllMaterialsAsDirty(1)}get boundingBoxSize(){return this._boundingBoxSize}constructor(e,t,r,a=!1,h=!0,d=!1,f=!1,l=null,o=null,c=!1,s=!1,n=!1){super(t),this._generateHarmonics=!0,this._onError=null,this._isBlocking=!0,this._rotationY=0,this.boundingBoxPosition=i.Zero(),this.onLoadObservable=new L,e&&(this._coordinatesMode=A.CUBIC_MODE,this.name=e,this.url=e,this.hasAlpha=!1,this.isCube=!0,this._textureMatrix=T.Identity(),this._prefilterOnLoad=f,this._prefilterIrradianceOnLoad=s,this._prefilterUsingCdf=n,this._onLoad=()=>{this.onLoadObservable.notifyObservers(this),l&&l()},this._onError=o,this.gammaSpace=d,this._noMipmap=a,this._size=r,this._supersample=c||n,this._generateHarmonics=h,this._texture=this._getFromCache(e,this._noMipmap,void 0,void 0,void 0,this.isCube),this._texture?this._texture.isReady?P.SetImmediate(()=>this._onLoad()):this._texture.onLoadedObservable.add(this._onLoad):this.getScene()?.useDelayedTextureLoading?this.delayLoadState=4:this._loadTexture())}getClassName(){return"EnvCubeTexture"}_loadTexture(){const e=this._getEngine(),t=e.getCaps();let r=0;t.textureFloat&&t.textureFloatLinearFiltering?r=1:t.textureHalfFloat&&t.textureHalfFloatLinearFiltering&&(r=2);const a=async h=>{this.lodGenerationOffset=0,this.lodGenerationScale=.8;const d=await this._getCubeMapTextureDataAsync(h,this._size,this._supersample);if(this._generateHarmonics){const c=v.ConvertCubeMapToSphericalPolynomial(d);this.sphericalPolynomial=c}const f=[];let l=null,o=null;for(let c=0;c<6;c++){r===2?o=new Uint16Array(this._size*this._size*3):r===0&&(l=new Uint8Array(this._size*this._size*3));const s=d[_._FacesMapping[c]];if(this.gammaSpace||o||l){for(let n=0;n<this._size*this._size;n++)if(this.gammaSpace&&(s[n*3+0]=Math.pow(s[n*3+0],x),s[n*3+1]=Math.pow(s[n*3+1],x),s[n*3+2]=Math.pow(s[n*3+2],x)),o&&(o[n*3+0]=y(s[n*3+0]),o[n*3+1]=y(s[n*3+1]),o[n*3+2]=y(s[n*3+2])),l){let m=Math.max(s[n*3+0]*255,0),g=Math.max(s[n*3+1]*255,0),w=Math.max(s[n*3+2]*255,0);const b=Math.max(Math.max(m,g),w);if(b>255){const S=255/b;m*=S,g*=S,w*=S}l[n*3+0]=m,l[n*3+1]=g,l[n*3+2]=w}}o?f.push(o):l?f.push(l):f.push(s)}return f};if(e._features.allowTexturePrefiltering&&(this._prefilterOnLoad||this._prefilterIrradianceOnLoad)){const h=this._onLoad,d=new G(e);this._onLoad=()=>{let f=Promise.resolve(null),l=Promise.resolve();this._prefilterIrradianceOnLoad&&(f=new z(e,{useCdf:this._prefilterUsingCdf}).prefilter(this)),this._prefilterOnLoad&&(l=d.prefilter(this)),Promise.all([f,l]).then(o=>{const c=o[0];if(this._prefilterIrradianceOnLoad&&c){this.irradianceTexture=c;const s=this.getScene();s&&s.markAllMaterialsAsDirty(1)}h&&h()})}}this._texture=e.createRawCubeTextureFromUrl(this.url,this.getScene(),this._size,4,r,this._noMipmap,a,null,this._onLoad,this._onError)}delayLoad(){this.delayLoadState===4&&(this.delayLoadState=1,this._texture=this._getFromCache(this.url,this._noMipmap),this._texture||this._loadTexture())}getReflectionTextureMatrix(){return this._textureMatrix}setReflectionTextureMatrix(e){this._textureMatrix=e,e.updateFlag!==this._textureMatrix.updateFlag&&e.isIdentity()!==this._textureMatrix.isIdentity()&&this.getScene()?.markAllMaterialsAsDirty(1,t=>t.getActiveTextures().indexOf(this)!==-1)}dispose(){this.onLoadObservable.clear(),super.dispose()}serialize(){if(!this.name)return null;const e={};return e.name=this.name,e.hasAlpha=this.hasAlpha,e.isCube=!0,e.level=this.level,e.size=this._size,e.coordinatesMode=this.coordinatesMode,e.useInGammaSpace=this.gammaSpace,e.generateHarmonics=this._generateHarmonics,e.noMipmap=this._noMipmap,e.isBlocking=this._isBlocking,e.rotationY=this._rotationY,e}clone(){const e=this._instantiateClone();return e.level=this.level,e.wrapU=this.wrapU,e.wrapV=this.wrapV,e.coordinatesIndex=this.coordinatesIndex,e.coordinatesMode=this.coordinatesMode,e}static _Parse(e,t){t.name=e.name,t.hasAlpha=e.hasAlpha,t.level=e.level,t.coordinatesMode=e.coordinatesMode,t.isBlocking=e.isBlocking,e.boundingBoxPosition&&(t.boundingBoxPosition=i.FromArray(e.boundingBoxPosition)),e.boundingBoxSize&&(t.boundingBoxSize=i.FromArray(e.boundingBoxSize)),e.rotationY&&(t.rotationY=e.rotationY)}}_._FacesMapping=["right","left","up","down","front","back"];class u extends _{constructor(e,t,r,a=!1,h=!0,d=!1,f=!1,l=null,o=null,c=!1,s=!1,n=!1){super(e,t,r,a,h,d,f,l,o,c,s,n)}getClassName(){return"HDRCubeTexture"}async _getCubeMapTextureDataAsync(e,t,r){return D(e,t,r)}_instantiateClone(){return new u(this.url,this.getScene()||this._getEngine(),this._size,this._noMipmap,this._generateHarmonics,this.gammaSpace)}serialize(){const e=super.serialize();return e?(e.customType="BABYLON.HDRCubeTexture",e):null}static Parse(e,t,r){if(!e.name||e.isRenderTarget)return null;const a=new u(r+e.name,t,e.size,e.noMipmap,e.generateHarmonics,e.useInGammaSpace);return this._Parse(e,a),a}}E("BABYLON.HDRCubeTexture",u);export{u as HDRCubeTexture};
