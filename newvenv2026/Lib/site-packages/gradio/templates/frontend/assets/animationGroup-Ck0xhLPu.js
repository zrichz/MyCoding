import{az as A,M as F,bp as x,bq as E,br as R,bs as M,bt as N,bu as B,bv as k,O as P,d as T,Q as S,V as C,c as D,b3 as W,E as K,bc as w}from"./index-Dtj0WP_z.js";import{B as U}from"./bone-DTFn1dTu.js";import"./index-Dw8Uzof1.js";import"./svelte/svelte_svelte.js";import"./svelte/svelte_animate.js";import"./svelte/svelte_attachments.js";import"./svelte/svelte_easing.js";import"./svelte/svelte_internal_client.js";import"./svelte/svelte_internal_flags_async.js";import"./svelte/svelte_internal_flags_legacy.js";import"./svelte/svelte_internal_flags_tracing.js";import"./svelte/svelte_internal_server.js";import"./svelte/svelte_legacy.js";import"./svelte/svelte_motion.js";import"./svelte/svelte_reactivity.js";import"./svelte/svelte_reactivity_window.js";import"./svelte/svelte_server.js";import"./svelte/svelte_store.js";import"./svelte/svelte_transition.js";import"./svelte/svelte_events.js";class Y{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(t,e,i,n){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._coreRuntimeAnimation=null,this._animation=e,this._target=t,this._scene=i,this._host=n,this._activeTargets=[],e._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===A.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=F.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minFrame!==0){const a={frame:0,value:this._keys[0].value};this._keys.splice(0,0,a)}if(this._target instanceof Array){let a=0;for(const o of this._target)this._preparePath(o,a),this._getOriginalValues(a),a++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const s=e.getEvents();if(s&&s.length>0)for(const a of s)this._events.push(a._clone());this._enableBlending=t&&t.animationPropertiesOverride?t.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(t,e=0){const i=this._animation.targetPropertyPath;if(i.length>1){let n=t;for(let s=0;s<i.length-1;s++){const a=i[s];if(n=n[a],n===void 0)throw new Error(`Invalid property (${a}) in property path (${i.join(".")})`)}this._targetPath=i[i.length-1],this._activeTargets[e]=n}else this._targetPath=i[0],this._activeTargets[e]=t;if(this._activeTargets[e][this._targetPath]===void 0)throw new Error(`Invalid property (${this._targetPath}) in property path (${i.join(".")})`)}get animation(){return this._animation}reset(t=!1){if(t)if(this._target instanceof Array){let e=0;for(const i of this._target)this._originalValue[e]!==void 0&&this._setValue(i,this._activeTargets[e],this._originalValue[e],-1,e),e++}else this._originalValue[0]!==void 0&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let e=0;e<this._events.length;e++)this._events[e].isDone=!1}isStopped(){return this._stopped}dispose(){const t=this._animation.runtimeAnimations.indexOf(this);t>-1&&this._animation.runtimeAnimations.splice(t,1)}setValue(t,e){if(this._targetIsArray){for(let i=0;i<this._target.length;i++){const n=this._target[i];this._setValue(n,this._activeTargets[i],t,e,i)}return}this._setValue(this._target,this._directTarget,t,e,0)}_getOriginalValues(t=0){let e;const i=this._activeTargets[t];i.getLocalMatrix&&this._targetPath==="_matrix"?e=i.getLocalMatrix():e=i[this._targetPath],e&&e.clone?this._originalValue[t]=e.clone():this._originalValue[t]=e}_registerTargetForLateAnimationBinding(t,e){const i=t.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(i),i._lateAnimationHolders||(i._lateAnimationHolders={}),i._lateAnimationHolders[t.targetPath]||(i._lateAnimationHolders[t.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:e}),t.isAdditive?(i._lateAnimationHolders[t.targetPath].additiveAnimations.push(t),i._lateAnimationHolders[t.targetPath].totalAdditiveWeight+=t.weight):(i._lateAnimationHolders[t.targetPath].animations.push(t),i._lateAnimationHolders[t.targetPath].totalWeight+=t.weight)}_setValue(t,e,i,n,s){if(this._currentActiveTarget=e,this._weight=n,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const o=e[this._targetPath];o.clone?this._originalBlendValue=o.clone():this._originalBlendValue=o}this._originalBlendValue.m?A.AllowMatrixDecomposeForInterpolation?this._currentValue?F.DecomposeLerpToRef(this._originalBlendValue,i,this._blendingFactor,this._currentValue):this._currentValue=F.DecomposeLerp(this._originalBlendValue,i,this._blendingFactor):this._currentValue?F.LerpToRef(this._originalBlendValue,i,this._blendingFactor,this._currentValue):this._currentValue=F.Lerp(this._originalBlendValue,i,this._blendingFactor):this._currentValue=A._UniversalLerp(this._originalBlendValue,i,this._blendingFactor);const a=t&&t.animationPropertiesOverride?t.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=a}else this._currentValue?this._currentValue.copyFrom?this._currentValue.copyFrom(i):this._currentValue=i:i?.clone?this._currentValue=i.clone():this._currentValue=i;n!==-1?this._registerTargetForLateAnimationBinding(this,this._originalValue[s]):this._animationState.loopMode===A.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[s],e[this._targetPath]):e[this._targetPath]=this._originalValue[s]+this._currentValue:e[this._targetPath]=this._currentValue,t.markAsDirty&&t.markAsDirty(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(t,e=-1){const i=this._animation.getKeys();t<i[0].frame?t=i[0].frame:t>i[i.length-1].frame&&(t=i[i.length-1].frame);const n=this._events;if(n.length)for(let a=0;a<n.length;a++)n[a].onlyOnce||(n[a].isDone=n[a].frame<t);this._currentFrame=t;const s=this._animation._interpolate(t,this._animationState);this.setValue(s,e)}_prepareForSpeedRatioChange(t){const e=this._previousElapsedTime*(this._animation.framePerSecond*t)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-e}animate(t,e,i,n,s,a=-1){const o=this._animation,r=o.targetPropertyPath;if(!r||r.length<1)return this._stopped=!0,!1;let l=!0,u;const c=this._events;let g=0;if(this._coreRuntimeAnimation)g=i-e,u=this._coreRuntimeAnimation.currentFrame,this._currentFrame=u,this._animationState.repeatCount=this._coreRuntimeAnimation._animationState.repeatCount,this._animationState.highLimitValue=this._coreRuntimeAnimation._animationState.highLimitValue,this._animationState.offsetValue=this._coreRuntimeAnimation._animationState.offsetValue;else{(e<this._minFrame||e>this._maxFrame)&&(e=this._minFrame),(i<this._minFrame||i>this._maxFrame)&&(i=this._maxFrame),g=i-e;let _,m=t*(o.framePerSecond*s)/1e3+this._absoluteFrameOffset,b=0,v=!1;const O=n&&this._animationState.loopMode===A.ANIMATIONLOOPMODE_YOYO;if(O){const f=(m-e)/g,p=Math.sin(f*Math.PI);m=Math.abs(p)*g+e;const I=p>=0?1:-1;this._yoyoDirection!==I&&(v=!0),this._yoyoDirection=I}if(this._previousElapsedTime=t,this._previousAbsoluteFrame=m,!n&&i>=e&&(m>=g&&s>0||m<=0&&s<0))l=!1,b=o.evaluate(i);else if(!n&&e>=i&&(m<=g&&s<0||m>=0&&s>0))l=!1,b=o.evaluate(e);else if(this._animationState.loopMode!==A.ANIMATIONLOOPMODE_CYCLE){const f=i.toString()+e.toString();if(!this._offsetsCache[f]){this._animationState.repeatCount=0,this._animationState.loopMode=A.ANIMATIONLOOPMODE_CYCLE;const p=o._interpolate(e,this._animationState),y=o._interpolate(i,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),o.dataType){case A.ANIMATIONTYPE_FLOAT:this._offsetsCache[f]=y-p;break;case A.ANIMATIONTYPE_QUATERNION:this._offsetsCache[f]=y.subtract(p);break;case A.ANIMATIONTYPE_VECTOR3:this._offsetsCache[f]=y.subtract(p);break;case A.ANIMATIONTYPE_VECTOR2:this._offsetsCache[f]=y.subtract(p);break;case A.ANIMATIONTYPE_SIZE:this._offsetsCache[f]=y.subtract(p);break;case A.ANIMATIONTYPE_COLOR3:this._offsetsCache[f]=y.subtract(p);break}this._highLimitsCache[f]=y}b=this._highLimitsCache[f],_=this._offsetsCache[f]}if(_===void 0)switch(o.dataType){case A.ANIMATIONTYPE_FLOAT:_=0;break;case A.ANIMATIONTYPE_QUATERNION:_=B;break;case A.ANIMATIONTYPE_VECTOR3:_=N;break;case A.ANIMATIONTYPE_VECTOR2:_=M;break;case A.ANIMATIONTYPE_SIZE:_=R;break;case A.ANIMATIONTYPE_COLOR3:_=E;break;case A.ANIMATIONTYPE_COLOR4:_=x;break}if(this._host&&this._host.syncRoot){const f=this._host.syncRoot,p=(f.masterFrame-f.fromFrame)/(f.toFrame-f.fromFrame);u=e+g*p}else m>0&&e>i||m<0&&e<i?u=l&&g!==0?i+m%g:e:u=l&&g!==0?e+m%g:i;if(!O&&(s>0&&this.currentFrame>u||s<0&&this.currentFrame<u)||O&&v){this._onLoop();for(let f=0;f<c.length;f++)c[f].onlyOnce||(c[f].isDone=!1);this._animationState.key=s>0?0:o.getKeys().length-1}this._currentFrame=u,this._animationState.repeatCount=g===0?0:m/g>>0,this._animationState.highLimitValue=b,this._animationState.offsetValue=_}const d=o._interpolate(u,this._animationState);if(this.setValue(d,a),c.length){for(let _=0;_<c.length;_++)if(g>=0&&u>=c[_].frame&&c[_].frame>=e||g<0&&u<=c[_].frame&&c[_].frame<=e){const m=c[_];m.isDone||(m.onlyOnce&&(c.splice(_,1),_--),m.isDone=!0,m.action(u))}}return l||(this._stopped=!0),l}}class L{get syncRoot(){return this._syncRoot}get masterFrame(){return this._runtimeAnimations.length===0?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(t){if(t===-1){this._weight=-1;return}this._weight=Math.min(Math.max(t,0),1)}get speedRatio(){return this._speedRatio}set speedRatio(t){for(let e=0;e<this._runtimeAnimations.length;e++)this._runtimeAnimations[e]._prepareForSpeedRatioChange(t);this._speedRatio=t,this._goToFrame!==null&&this.goToFrame(this._goToFrame)}get elapsedTime(){return this._localDelayOffset===null?0:this._scene._animationTime-this._localDelayOffset}constructor(t,e,i=0,n=100,s=!1,a=1,o,r,l,u=!1,c=0){this.target=e,this.fromFrame=i,this.toFrame=n,this.loopAnimation=s,this.onAnimationEnd=o,this.onAnimationLoop=l,this.isAdditive=u,this.playOrder=c,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this._paused=!1,this._speedRatio=1,this._weight=-1,this._previousWeight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new P,this.onAnimationLoopObservable=new P,this._scene=t,r&&this.appendAnimations(e,r),this._speedRatio=a,t._activeAnimatables.push(this)}syncWith(t){if(this._syncRoot=t,t){const e=this._scene._activeAnimatables.indexOf(this);e>-1&&(this._scene._activeAnimatables.splice(e,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(t,e){for(let i=0;i<e.length;i++){const n=e[i],s=new Y(t,n,this._scene,this);s._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(s)}}getAnimationByTargetProperty(t){const e=this._runtimeAnimations;for(let i=0;i<e.length;i++)if(e[i].animation.targetProperty===t)return e[i].animation;return null}getRuntimeAnimationByTargetProperty(t){const e=this._runtimeAnimations;for(let i=0;i<e.length;i++)if(e[i].animation.targetProperty===t)return e[i];return null}reset(){const t=this._runtimeAnimations;for(let e=0;e<t.length;e++)t[e].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(t){const e=this._runtimeAnimations;for(let i=0;i<e.length;i++)e[i].animation.enableBlending=!0,e[i].animation.blendingSpeed=t}disableBlending(){const t=this._runtimeAnimations;for(let e=0;e<t.length;e++)t[e].animation.enableBlending=!1}goToFrame(t,e=!1){const i=this._runtimeAnimations;if(i[0]){const n=i[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??i[0].currentFrame;const s=this.speedRatio===0?0:(t-this._frameToSyncFromJump)/n*1e3/this.speedRatio;this._manualJumpDelay=-s}for(let n=0;n<i.length;n++)i[n].goToFrame(t,e?this._weight:-1);this._goToFrame=t}get paused(){return this._paused}pause(){this._paused||(this._paused=!0)}restart(){this._paused=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(t,e,i=!1,n=!1){if(t||e){const s=this._scene._activeAnimatables.indexOf(this);if(s>-1){const a=this._runtimeAnimations;for(let o=a.length-1;o>=0;o--){const r=a[o];t&&r.animation.name!=t||e&&!e(r.target)||(r.dispose(),a.splice(o,1))}a.length==0&&(i||this._scene._activeAnimatables.splice(s,1),n||this._raiseOnAnimationEnd())}}else{const s=this._scene._activeAnimatables.indexOf(this);if(s>-1){i||this._scene._activeAnimatables.splice(s,1);const a=this._runtimeAnimations;for(let o=0;o<a.length;o++)a[o].dispose();this._runtimeAnimations.length=0,n||this._raiseOnAnimationEnd()}}}async waitAsync(){return await new Promise(t=>{this.onAnimationEndObservable.add(()=>{t(this)},void 0,void 0,this,!0)})}_animate(t){if(this._paused)return this.animationStarted=!1,this._pausedDelay===null&&(this._pausedDelay=t),!0;if(this._localDelayOffset===null?(this._localDelayOffset=t,this._pausedDelay=null):this._pausedDelay!==null&&(this._localDelayOffset+=t-this._pausedDelay,this._pausedDelay=null),this._manualJumpDelay!==null&&(this._localDelayOffset+=this.speedRatio<0?-this._manualJumpDelay:this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,!L.ProcessPausedAnimatables&&this._weight===0&&this._previousWeight===0)return!0;this._previousWeight=this._weight;let e=!1;const i=this._runtimeAnimations;let n;for(n=0;n<i.length;n++){const a=i[n].animate(t-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);e=e||a}if(this.animationStarted=e,!e){if(this.disposeOnEnd)for(n=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(n,1),n=0;n<i.length;n++)i[n].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return e}}L.ProcessPausedAnimatables=!1;function z(h){if(h.totalWeight===0&&h.totalAdditiveWeight===0)return h.originalValue;let t=1;const e=T.Vector3[0],i=T.Vector3[1],n=T.Quaternion[0];let s=0;const a=h.animations[0],o=h.originalValue;let r=1,l=!1;if(h.totalWeight<1)r=1-h.totalWeight,o.decompose(i,n,e);else{if(s=1,t=h.totalWeight,r=a.weight/t,r==1)if(h.totalAdditiveWeight)l=!0;else return a.currentValue;a.currentValue.decompose(i,n,e)}if(!l){i.scaleInPlace(r),e.scaleInPlace(r),n.scaleInPlace(r);for(let c=s;c<h.animations.length;c++){const g=h.animations[c];if(g.weight===0)continue;r=g.weight/t;const d=T.Vector3[2],_=T.Vector3[3],m=T.Quaternion[1];g.currentValue.decompose(_,m,d),_.scaleAndAddToRef(r,i),m.scaleAndAddToRef(S.Dot(n,m)>0?r:-r,n),d.scaleAndAddToRef(r,e)}n.normalize()}for(let c=0;c<h.additiveAnimations.length;c++){const g=h.additiveAnimations[c];if(g.weight===0)continue;const d=T.Vector3[2],_=T.Vector3[3],m=T.Quaternion[1];g.currentValue.decompose(_,m,d),_.multiplyToRef(i,_),C.LerpToRef(i,_,g.weight,i),n.multiplyToRef(m,m),S.SlerpToRef(n,m,g.weight,n),d.scaleAndAddToRef(g.weight,e)}const u=a?a._animationState.workValue:T.Matrix[0].clone();return F.ComposeToRef(i,n,e,u),u}function H(h,t){if(h.totalWeight===0&&h.totalAdditiveWeight===0)return t;const e=h.animations[0],i=h.originalValue;let n=t;if(h.totalWeight===0&&h.totalAdditiveWeight>0)n.copyFrom(i);else if(h.animations.length===1){if(S.SlerpToRef(i,e.currentValue,Math.min(1,h.totalWeight),n),h.totalAdditiveWeight===0)return n}else if(h.animations.length>1){let s=1,a,o;if(h.totalWeight<1){const l=1-h.totalWeight;a=[],o=[],a.push(i),o.push(l)}else{if(h.animations.length===2&&(S.SlerpToRef(h.animations[0].currentValue,h.animations[1].currentValue,h.animations[1].weight/h.totalWeight,t),h.totalAdditiveWeight===0))return t;a=[],o=[],s=h.totalWeight}for(let l=0;l<h.animations.length;l++){const u=h.animations[l];a.push(u.currentValue),o.push(u.weight/s)}let r=0;for(let l=0;l<a.length;){if(!l){S.SlerpToRef(a[l],a[l+1],o[l+1]/(o[l]+o[l+1]),t),n=t,r=o[l]+o[l+1],l+=2;continue}r+=o[l],S.SlerpToRef(n,a[l],o[l]/r,n),l++}}for(let s=0;s<h.additiveAnimations.length;s++){const a=h.additiveAnimations[s];a.weight!==0&&(n.multiplyToRef(a.currentValue,T.Quaternion[0]),S.SlerpToRef(n,T.Quaternion[0],a.weight,n))}return n}function X(h){if(h._registeredForLateAnimationBindings.length){for(let t=0;t<h._registeredForLateAnimationBindings.length;t++){const e=h._registeredForLateAnimationBindings.data[t];for(const i in e._lateAnimationHolders){const n=e._lateAnimationHolders[i],s=n.animations[0],a=n.originalValue;if(a==null)continue;const o=A.AllowMatrixDecomposeForInterpolation&&a.m;let r=e[i];if(o)r=z(n);else if(a.w!==void 0)r=H(n,r||S.Identity());else{let u=0,c=1;const g=s&&s._animationState.loopMode===A.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(n.totalWeight<1)g?r=a.clone?a.clone():a:s&&a.scale?r=a.scale(1-n.totalWeight):s?r=a*(1-n.totalWeight):a.clone?r=a.clone():r=a;else if(s){c=n.totalWeight;const d=s.weight/c;d!==1?s.currentValue.scale?r=s.currentValue.scale(d):r=s.currentValue*d:r=s.currentValue,g&&(r.addToRef?r.addToRef(a,r):r+=a),u=1}for(let d=u;d<n.animations.length;d++){const _=n.animations[d],m=_.weight/c;if(m)_.currentValue.scaleAndAddToRef?_.currentValue.scaleAndAddToRef(m,r):r+=_.currentValue*m;else continue}for(let d=0;d<n.additiveAnimations.length;d++){const _=n.additiveAnimations[d],m=_.weight;if(m)_.currentValue.scaleAndAddToRef?_.currentValue.scaleAndAddToRef(m,r):r+=_.currentValue*m;else continue}}e[i]=r}e._lateAnimationHolders={}}h._registeredForLateAnimationBindings.reset()}}function J(h,t){t&&(t.prototype.copyAnimationRange=function(e,i,n,s=!1,a=null){this.animations.length===0&&(this.animations.push(new A(this.name,"_matrix",e.animations[0].framePerSecond,A.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const o=e.animations[0].getRange(i);if(!o)return!1;const r=o.from,l=o.to,u=e.animations[0].getKeys(),c=e.length,g=e.getParent(),d=this.getParent(),_=s&&g&&c&&this.length&&c!==this.length,m=_&&d&&g?d.length/g.length:1,b=s&&!d&&a&&(a.x!==1||a.y!==1||a.z!==1),v=this.animations[0].getKeys();let O,f,p;for(let y=0,I=u.length;y<I;y++)O=u[y],O.frame>=r&&O.frame<=l&&(s?(p=O.value.clone(),_?(f=p.getTranslation(),p.setTranslation(f.scaleInPlace(m))):b&&a?(f=p.getTranslation(),p.setTranslation(f.multiplyInPlace(a))):p=O.value):p=O.value,v.push({frame:O.frame+n,value:p}));return this.animations[0].createRange(i,r+n,l+n),!0}),h&&(h.prototype._animate=function(e){if(!this.animationsEnabled)return;const i=k.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=i}this.deltaTime=e!==void 0?e:this.useConstantAnimationDeltaTime?16:(i-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=i;const n=this._activeAnimatables;if(n.length===0)return;this._animationTime+=this.deltaTime;const s=this._animationTime;for(let a=0;a<n.length;a++){const o=n[a];!o._animate(s)&&o.disposeOnEnd&&a--}X(this)},h.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort((e,i)=>e.playOrder-i.playOrder)},h.prototype.beginWeightedAnimation=function(e,i,n,s=1,a,o=1,r,l,u,c,g=!1){const d=this.beginAnimation(e,i,n,a,o,r,l,!1,u,c,g);return d.weight=s,d},h.prototype.beginAnimation=function(e,i,n,s,a=1,o,r,l=!0,u,c,g=!1){if(a<0){const _=i;i=n,n=_,a=-a}i>n&&(a=-a),l&&this.stopAnimation(e,void 0,u),r||(r=new L(this,e,i,n,s,a,o,void 0,c,g));const d=u?u(e):!0;if(e.animations&&d&&r.appendAnimations(e,e.animations),e.getAnimatables){const _=e.getAnimatables();for(let m=0;m<_.length;m++)this.beginAnimation(_[m],i,n,s,a,o,r,l,u,c)}return r.reset(),r},h.prototype.beginHierarchyAnimation=function(e,i,n,s,a,o=1,r,l,u=!0,c,g,d=!1){const _=e.getDescendants(i),m=[];m.push(this.beginAnimation(e,n,s,a,o,r,l,u,c,void 0,d));for(const b of _)m.push(this.beginAnimation(b,n,s,a,o,r,l,u,c,void 0,d));return m},h.prototype.beginDirectAnimation=function(e,i,n,s,a,o=1,r,l,u=!1){if(o<0){const g=n;n=s,s=g,o=-o}return n>s&&(o=-o),new L(this,e,n,s,a,o,r,i,l,u)},h.prototype.beginDirectHierarchyAnimation=function(e,i,n,s,a,o,r,l,u,c=!1){const g=e.getDescendants(i),d=[];d.push(this.beginDirectAnimation(e,n,s,a,o,r,l,u,c));for(const _ of g)d.push(this.beginDirectAnimation(_,n,s,a,o,r,l,u,c));return d},h.prototype.getAnimatableByTarget=function(e){for(let i=0;i<this._activeAnimatables.length;i++)if(this._activeAnimatables[i].target===e)return this._activeAnimatables[i];return null},h.prototype.getAllAnimatablesByTarget=function(e){const i=[];for(let n=0;n<this._activeAnimatables.length;n++)this._activeAnimatables[n].target===e&&i.push(this._activeAnimatables[n]);return i},h.prototype.stopAnimation=function(e,i,n){const s=this.getAllAnimatablesByTarget(e);for(const a of s)a.stop(i,n)},h.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let e=0;e<this._activeAnimatables.length;e++)this._activeAnimatables[e].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const e of this.animationGroups)e.stop()})}J(D,U);class Q{getClassName(){return"TargetedAnimation"}constructor(t){this.parent=t,this.uniqueId=W.UniqueId}serialize(){const t={};return t.animation=this.animation.serialize(),t.targetId=this.target.id,t}}class V{get mask(){return this._mask}set mask(t){this._mask!==t&&(this._mask=t,this.syncWithMask(!0))}syncWithMask(t=!1){if(!this.mask&&!t){this._numActiveAnimatables=this._targetedAnimations.length;return}this._numActiveAnimatables=0;for(let e=0;e<this._animatables.length;++e){const i=this._animatables[e];!this.mask||this.mask.disabled||this.mask.retainsTarget(i.target.name)?(this._numActiveAnimatables++,i.paused&&i.restart()):i.paused||i.pause()}}removeUnmaskedAnimations(){if(!(!this.mask||this.mask.disabled)){for(let t=0;t<this._animatables.length;++t){const e=this._animatables[t];this.mask.retainsTarget(e.target.name)||(e.stop(),this._animatables.splice(t,1),--t)}for(let t=0;t<this._targetedAnimations.length;t++){const e=this._targetedAnimations[t];this.mask.retainsTarget(e.target.name)||(this._targetedAnimations.splice(t,1),--t)}}}get from(){return this._from}set from(t){if(this._from!==t){this._from=t;for(let e=0;e<this._animatables.length;e++){const i=this._animatables[e];i.fromFrame=this._from}}}get to(){return this._to}set to(t){if(this._to!==t){this._to=t;for(let e=0;e<this._animatables.length;e++){const i=this._animatables[e];i.toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(t){if(this._speedRatio!==t){this._speedRatio=t;for(let e=0;e<this._animatables.length;e++){const i=this._animatables[e];i.speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(t){if(this._loopAnimation!==t){this._loopAnimation=t;for(let e=0;e<this._animatables.length;e++){const i=this._animatables[e];i.loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(t){if(this._isAdditive!==t){this._isAdditive=t;for(let e=0;e<this._animatables.length;e++){const i=this._animatables[e];i.isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(t){this._weight!==t&&(this._weight=t,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(t){if(this._playOrder!==t&&(this._playOrder=t,this._animatables.length>0)){for(let e=0;e<this._animatables.length;e++)this._animatables[e].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(t){if(this._enableBlending!==t&&(this._enableBlending=t,t!==null))for(let e=0;e<this._targetedAnimations.length;++e)this._targetedAnimations[e].animation.enableBlending=t}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(t){if(this._blendingSpeed!==t&&(this._blendingSpeed=t,t!==null))for(let e=0;e<this._targetedAnimations.length;++e)this._targetedAnimations[e].animation.blendingSpeed=t}getLength(t,e){t=t??this._from,e=e??this._to;const i=this.targetedAnimations[0].animation.framePerSecond*this._speedRatio;return(e-t)/i}static MergeAnimationGroups(t,e=!0,i=!1,n){if(t.length===0)return null;n=n??t[0].weight;let s=Number.MAX_VALUE,a=-Number.MAX_VALUE;if(i)for(const r of t)r.from<s&&(s=r.from),r.to>a&&(a=r.to);const o=new V(t[0].name+"_merged",t[0]._scene,n);for(const r of t){i&&r.normalize(s,a);for(const l of r.targetedAnimations)o.addTargetedAnimation(l.animation,l.target);e&&r.dispose()}return o}getScene(){return this._scene}constructor(t,e=null,i=-1,n=0){this.name=t,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new P,this.onAnimationLoopObservable=new P,this.onAnimationGroupLoopObservable=new P,this.onAnimationGroupEndObservable=new P,this.onAnimationGroupPauseObservable=new P,this.onAnimationGroupPlayObservable=new P,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=e||K.LastCreatedScene,this._weight=i,this._playOrder=n,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(t,e){const i=new Q(this);i.animation=t,i.target=e;const n=t.getKeys();return this._from>n[0].frame&&(this._from=n[0].frame),this._to<n[n.length-1].frame&&(this._to=n[n.length-1].frame),this._enableBlending!==null&&(t.enableBlending=this._enableBlending),this._blendingSpeed!==null&&(t.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(i),this._shouldStart=!0,i}removeTargetedAnimation(t){for(let e=this._targetedAnimations.length-1;e>-1;e--)this._targetedAnimations[e].animation===t&&this._targetedAnimations.splice(e,1)}normalize(t=null,e=null){t==null&&(t=this._from),e==null&&(e=this._to);for(let i=0;i<this._targetedAnimations.length;i++){const s=this._targetedAnimations[i].animation.getKeys(),a=s[0],o=s[s.length-1];if(a.frame>t){const r={frame:t,value:a.value,inTangent:a.inTangent,outTangent:a.outTangent,interpolation:a.interpolation};s.splice(0,0,r)}if(o.frame<e){const r={frame:e,value:o.value,inTangent:o.inTangent,outTangent:o.outTangent,interpolation:o.interpolation};s.push(r)}}return this._from=t,this._to=e,this}_processLoop(t,e,i){t.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(e),!this._animationLoopFlags[i]&&(this._animationLoopFlags[i]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(t=!1,e=1,i,n,s){if(this._isStarted||this._targetedAnimations.length===0)return this;this._loopAnimation=t,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let a=0;a<this._targetedAnimations.length;a++){const o=this._targetedAnimations[a],r=this._scene.beginDirectAnimation(o.target,[o.animation],i!==void 0?i:this._from,n!==void 0?n:this._to,t,e,void 0,void 0,s!==void 0?s:this._isAdditive);r.weight=this._weight,r.playOrder=this._playOrder,r.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(o),this._checkAnimationGroupEnded(r)},this._processLoop(r,o,a),this._animatables.push(r)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=e,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let t=0;t<this._animatables.length;t++)this._animatables[t].pause();return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(t){return this.isStarted&&this._animatables.length&&!this._shouldStart?(t!==void 0&&(this.loopAnimation=t),this.restart()):(this.stop(),this.start(t,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let t=0;t<this._animatables.length;t++)this._animatables[t].reset();return this}restart(){if(!this._isStarted)return this;for(let t=0;t<this._animatables.length;t++)this._animatables[t].restart();return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(t=!1){if(!this._isStarted)return this;const e=this._animatables.slice();for(let n=0;n<e.length;n++)e[n].stop(void 0,void 0,!0,t);let i=0;for(let n=0;n<this._scene._activeAnimatables.length;n++){const s=this._scene._activeAnimatables[n];s._runtimeAnimations.length>0?this._scene._activeAnimatables[i++]=s:t&&this._checkAnimationGroupEnded(s,t)}return this._scene._activeAnimatables.length=i,this._isStarted=!1,this}setWeightForAllAnimatables(t){for(let e=0;e<this._animatables.length;e++){const i=this._animatables[e];i.weight=t}return this}syncAllAnimationsWith(t){for(let e=0;e<this._animatables.length;e++)this._animatables[e].syncWith(t);return this}goToFrame(t,e=!1){if(!this._isStarted)return this;for(let i=0;i<this._animatables.length;i++)this._animatables[i].goToFrame(t,e);return this}getCurrentFrame(){return this.animatables[0]?.masterFrame||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const t=this._scene.animationGroups.indexOf(this);if(t>-1&&this._scene.animationGroups.splice(t,1),this._parentContainer){const e=this._parentContainer.animationGroups.indexOf(this);e>-1&&this._parentContainer.animationGroups.splice(e,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(t,e=!1){const i=this._animatables.indexOf(t);i>-1&&this._animatables.splice(i,1),this._animatables.length===this._targetedAnimations.length-this._numActiveAnimatables&&(this._isStarted=!1,e||this.onAnimationGroupEndObservable.notifyObservers(this),this._animatables.length=0)}clone(t,e,i=!1){const n=new V(t||this.name,this._scene,this._weight,this._playOrder);n._from=this.from,n._to=this.to,n._speedRatio=this.speedRatio,n._loopAnimation=this.loopAnimation,n._isAdditive=this.isAdditive,n._enableBlending=this.enableBlending,n._blendingSpeed=this.blendingSpeed,n.metadata=this.metadata,n.mask=this.mask;for(const s of this._targetedAnimations)n.addTargetedAnimation(i?s.animation.clone():s.animation,e?e(s.target):s.target);return n}serialize(){const t={};t.name=this.name,t.from=this.from,t.to=this.to,t.speedRatio=this.speedRatio,t.loopAnimation=this.loopAnimation,t.isAdditive=this.isAdditive,t.weight=this.weight,t.playOrder=this.playOrder,t.enableBlending=this.enableBlending,t.blendingSpeed=this.blendingSpeed,t.targetedAnimations=[];for(let e=0;e<this.targetedAnimations.length;e++){const i=this.targetedAnimations[e];t.targetedAnimations[e]=i.serialize()}return w&&w.HasTags(this)&&(t.tags=w.GetTags(this)),this.metadata&&(t.metadata=this.metadata),t}static Parse(t,e,i){const n=new V(t.name,e,t.weight,t.playOrder);for(let s=0;s<t.targetedAnimations.length;s++){const a=t.targetedAnimations[s],o=A.Parse(a.animation),r=a.targetId;if(a.animation.property==="influence"){const l=e.getMorphTargetById(r);l&&n.addTargetedAnimation(o,l)}else{const l=i?i.get(r):e.getNodeById(r);l!=null&&n.addTargetedAnimation(o,l)}}return w&&w.AddTagsTo(n,t.tags),t.from!==null&&t.to!==null&&n.normalize(t.from,t.to),t.speedRatio!==void 0&&(n._speedRatio=t.speedRatio),t.loopAnimation!==void 0&&(n._loopAnimation=t.loopAnimation),t.isAdditive!==void 0&&(n._isAdditive=t.isAdditive),t.weight!==void 0&&(n._weight=t.weight),t.playOrder!==void 0&&(n._playOrder=t.playOrder),t.enableBlending!==void 0&&(n._enableBlending=t.enableBlending),t.blendingSpeed!==void 0&&(n._blendingSpeed=t.blendingSpeed),t.metadata!==void 0&&(n.metadata=t.metadata),n}static MakeAnimationAdditive(t,e,i,n=!1,s){let a;typeof e=="object"?a=e:a={referenceFrame:e,range:i,cloneOriginalAnimationGroup:n,clonedAnimationName:s};let o=t;a.cloneOriginalAnimationGroup&&(o=t.clone(a.clonedAnimationGroupName||o.name));const r=o.targetedAnimations;for(let l=0;l<r.length;l++){const u=r[l];u.animation=A.MakeAnimationAdditive(u.animation,a)}if(o.isAdditive=!0,a.clipKeys){let l=Number.MAX_VALUE,u=-Number.MAX_VALUE;const c=o.targetedAnimations;for(let g=0;g<c.length;g++){const m=c[g].animation.getKeys();l>m[0].frame&&(l=m[0].frame),u<m[m.length-1].frame&&(u=m[m.length-1].frame)}o._from=l,o._to=u}return o}static ClipKeys(t,e,i,n,s){const a=t.clone(n||t.name);return V.ClipKeysInPlace(a,e,i,s)}static ClipKeysInPlace(t,e,i,n){return V.ClipInPlace(t,e,i,n,!1)}static ClipFrames(t,e,i,n,s){const a=t.clone(n||t.name);return V.ClipFramesInPlace(a,e,i,s)}static ClipFramesInPlace(t,e,i,n){return V.ClipInPlace(t,e,i,n,!0)}static ClipInPlace(t,e,i,n,s=!1){let a=Number.MAX_VALUE,o=-Number.MAX_VALUE;const r=t.targetedAnimations;for(let l=0;l<r.length;l++){const u=r[l],c=n?u.animation:u.animation.clone();s&&(c.createKeyForFrame(e),c.createKeyForFrame(i));const g=c.getKeys(),d=[];let _=Number.MAX_VALUE;for(let m=0;m<g.length;m++){const b=g[m];if(!s&&m>=e&&m<=i||s&&b.frame>=e&&b.frame<=i){const v={frame:b.frame,value:b.value.clone?b.value.clone():b.value,inTangent:b.inTangent,outTangent:b.outTangent,interpolation:b.interpolation,lockedTangent:b.lockedTangent};_===Number.MAX_VALUE&&(_=v.frame),v.frame-=_,d.push(v)}}if(d.length===0){r.splice(l,1),l--;continue}a>d[0].frame&&(a=d[0].frame),o<d[d.length-1].frame&&(o=d[d.length-1].frame),c.setKeys(d,!0),u.animation=c}return t._from=a,t._to=o,t}getClassName(){return"AnimationGroup"}toString(t){let e="Name: "+this.name;return e+=", type: "+this.getClassName(),t&&(e+=", from: "+this._from,e+=", to: "+this._to,e+=", isStarted: "+this._isStarted,e+=", speedRatio: "+this._speedRatio,e+=", targetedAnimations length: "+this._targetedAnimations.length,e+=", animatables length: "+this._animatables),e}}export{V as AnimationGroup,Q as TargetedAnimation};
