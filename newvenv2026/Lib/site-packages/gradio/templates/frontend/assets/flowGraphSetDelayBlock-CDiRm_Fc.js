import{a as c}from"./KHR_interactivity-BPqRt0iB.js";import{b as p,i as u,F as h}from"./declarationMapper-qDpwXXCa.js";import{O as n,L as d,R as v}from"./index-Dtj0WP_z.js";import"./index-Dw8Uzof1.js";import"./svelte/svelte_svelte.js";import"./svelte/svelte_animate.js";import"./svelte/svelte_attachments.js";import"./svelte/svelte_easing.js";import"./svelte/svelte_internal_client.js";import"./svelte/svelte_internal_flags_async.js";import"./svelte/svelte_internal_flags_legacy.js";import"./svelte/svelte_internal_flags_tracing.js";import"./svelte/svelte_internal_server.js";import"./svelte/svelte_legacy.js";import"./svelte/svelte_motion.js";import"./svelte/svelte_reactivity.js";import"./svelte/svelte_reactivity_window.js";import"./svelte/svelte_server.js";import"./svelte/svelte_store.js";import"./svelte/svelte_transition.js";import"./svelte/svelte_events.js";import"./objectModelMapping-wn7LYZ2M.js";var m;(function(r){r[r.INIT=0]="INIT",r[r.STARTED=1]="STARTED",r[r.ENDED=2]="ENDED"})(m||(m={}));class g{constructor(e){this.onEachCountObservable=new n,this.onTimerAbortedObservable=new n,this.onTimerEndedObservable=new n,this.onStateChangedObservable=new n,this._observer=null,this._breakOnNextTick=!1,this._tick=t=>{const i=Date.now();this._timer=i-this._startTime;const s={startTime:this._startTime,currentTime:i,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,payload:t},a=this._breakOnNextTick||this._breakCondition(s);a||this._timer>=this._timeToEnd?this._stop(s,a):this.onEachCountObservable.notifyObservers(s)},this._setState(0),this._contextObservable=e.contextObservable,this._observableParameters=e.observableParameters??{},this._breakCondition=e.breakCondition??(()=>!1),this._timeToEnd=e.timeout,e.onEnded&&this.onTimerEndedObservable.add(e.onEnded),e.onTick&&this.onEachCountObservable.add(e.onTick),e.onAborted&&this.onTimerAbortedObservable.add(e.onAborted)}set breakCondition(e){this._breakCondition=e}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(e=this._timeToEnd){if(this._state===1)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=e,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(1)}stop(){this._state===1&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(e){this._state=e,this.onStateChangedObservable.notifyObservers(this._state)}_stop(e,t=!1){this._contextObservable.remove(this._observer),this._setState(2),t?this.onTimerAbortedObservable.notifyObservers(e):this.onTimerEndedObservable.notifyObservers(e)}}class o extends c{constructor(e){super(e),this.cancel=this._registerSignalInput("cancel"),this.duration=this.registerDataInput("duration",p),this.lastDelayIndex=this.registerDataOutput("lastDelayIndex",u,new h(-1))}_preparePendingTasks(e){const t=this.duration.getValue(e);if(t<0||isNaN(t)||!isFinite(t))return this._reportError(e,"Invalid duration in SetDelay block");if(e._getGlobalContextVariable("activeDelays",0)>=o.MaxParallelDelayCount)return this._reportError(e,"Max parallel delays reached");const s=e._getGlobalContextVariable("lastDelayIndex",-1),a=e._getExecutionVariable(this,"pendingDelays",[]),_=e.configuration.scene,l=new g({timeout:t*1e3,contextObservable:_.onBeforeRenderObservable,onEnded:()=>this._onEnded(l,e)});l.start();const b=s+1;this.lastDelayIndex.setValue(new h(b),e),e._setGlobalContextVariable("lastDelayIndex",b),a[b]=l,e._setExecutionVariable(this,"pendingDelays",a),this._updateGlobalTimers(e)}_cancelPendingTasks(e){const t=e._getExecutionVariable(this,"pendingDelays",[]);for(const i of t)i?.dispose();e._deleteExecutionVariable(this,"pendingDelays"),this.lastDelayIndex.setValue(new h(-1),e),this._updateGlobalTimers(e)}_execute(e,t){if(t===this.cancel){this._cancelPendingTasks(e);return}else this._preparePendingTasks(e),this.out._activateSignal(e)}getClassName(){return"FlowGraphSetDelayBlock"}_onEnded(e,t){const i=t._getExecutionVariable(this,"pendingDelays",[]),s=i.indexOf(e);s!==-1?i.splice(s,1):d.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),t._removePendingBlock(this),this.done._activateSignal(t),this._updateGlobalTimers(t)}_updateGlobalTimers(e){const t=e._getExecutionVariable(this,"pendingDelays",[]),i=e._getGlobalContextVariable("pendingDelays",[]);for(let s=0;s<t.length;s++){if(!t[s])continue;const a=t[s];i[s]&&i[s]!==a?d.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"):i[s]=a}e._setGlobalContextVariable("pendingDelays",i)}}o.MaxParallelDelayCount=100;v("FlowGraphSetDelayBlock",o);export{o as FlowGraphSetDelayBlock};
