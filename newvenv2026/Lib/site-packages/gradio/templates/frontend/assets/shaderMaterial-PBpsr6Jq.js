import{P as V,M,m as l,n as I,o as N,p as F,q as R,r as q,c as j,t as L,u as W,v as z,w as D,x as G,y as K,f as E,a as S,Q as X,W as P,E as k,z as H,R as Q}from"./index-Dtj0WP_z.js";import"./index-Dw8Uzof1.js";import"./svelte/svelte_svelte.js";import"./svelte/svelte_animate.js";import"./svelte/svelte_attachments.js";import"./svelte/svelte_easing.js";import"./svelte/svelte_internal_client.js";import"./svelte/svelte_internal_flags_async.js";import"./svelte/svelte_internal_flags_legacy.js";import"./svelte/svelte_internal_flags_tracing.js";import"./svelte/svelte_internal_server.js";import"./svelte/svelte_legacy.js";import"./svelte/svelte_motion.js";import"./svelte/svelte_reactivity.js";import"./svelte/svelte_reactivity_window.js";import"./svelte/svelte_server.js";import"./svelte/svelte_store.js";import"./svelte/svelte_transition.js";import"./svelte/svelte_events.js";const b={effect:null,subMesh:null};class x extends V{constructor(t,s,o,e={},i=!0){super(t,s,i),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new M,this._cachedWorldViewProjectionMatrix=new M,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=o,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...e}}get shaderPath(){return this._shaderPath}set shaderPath(t){this._shaderPath=t}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(t){this._options.uniforms.indexOf(t)===-1&&this._options.uniforms.push(t)}setTexture(t,s){return this._options.samplers.indexOf(t)===-1&&this._options.samplers.push(t),this._textures[t]=s,this}removeTexture(t){delete this._textures[t]}setTextureArray(t,s){return this._options.samplers.indexOf(t)===-1&&this._options.samplers.push(t),this._checkUniform(t),this._textureArrays[t]=s,this}setExternalTexture(t,s){return this._options.externalTextures.indexOf(t)===-1&&this._options.externalTextures.push(t),this._externalTextures[t]=s,this}setFloat(t,s){return this._checkUniform(t),this._floats[t]=s,this}setInt(t,s){return this._checkUniform(t),this._ints[t]=s,this}setUInt(t,s){return this._checkUniform(t),this._uints[t]=s,this}setFloats(t,s){return this._checkUniform(t),this._floatsArrays[t]=s,this}setColor3(t,s){return this._checkUniform(t),this._colors3[t]=s,this}setColor3Array(t,s){return this._checkUniform(t),this._colors3Arrays[t]=s.reduce((o,e)=>(o.push(e.r,e.g,e.b),o),[]),this}setColor4(t,s){return this._checkUniform(t),this._colors4[t]=s,this}setColor4Array(t,s){return this._checkUniform(t),this._colors4Arrays[t]=s.reduce((o,e)=>(o.push(e.r,e.g,e.b,e.a),o),[]),this}setVector2(t,s){return this._checkUniform(t),this._vectors2[t]=s,this}setVector3(t,s){return this._checkUniform(t),this._vectors3[t]=s,this}setVector4(t,s){return this._checkUniform(t),this._vectors4[t]=s,this}setQuaternion(t,s){return this._checkUniform(t),this._quaternions[t]=s,this}setQuaternionArray(t,s){return this._checkUniform(t),this._quaternionsArrays[t]=s.reduce((o,e)=>(e.toArray(o,o.length),o),[]),this}setMatrix(t,s){return this._checkUniform(t),this._matrices[t]=s,this}setMatrices(t,s){this._checkUniform(t);const o=new Float32Array(s.length*16);for(let e=0;e<s.length;e++)s[e].copyToArray(o,e*16);return this._matrixArrays[t]=o,this}setMatrix3x3(t,s){return this._checkUniform(t),this._matrices3x3[t]=s,this}setMatrix2x2(t,s){return this._checkUniform(t),this._matrices2x2[t]=s,this}setArray2(t,s){return this._checkUniform(t),this._vectors2Arrays[t]=s,this}setArray3(t,s){return this._checkUniform(t),this._vectors3Arrays[t]=s,this}setArray4(t,s){return this._checkUniform(t),this._vectors4Arrays[t]=s,this}setUniformBuffer(t,s){return this._options.uniformBuffers.indexOf(t)===-1&&this._options.uniformBuffers.push(t),this._uniformBuffers[t]=s,this}setTextureSampler(t,s){return this._options.samplerObjects.indexOf(t)===-1&&this._options.samplerObjects.push(t),this._textureSamplers[t]=s,this}setStorageBuffer(t,s){return this._options.storageBuffers.indexOf(t)===-1&&this._options.storageBuffers.push(t),this._storageBuffers[t]=s,this}setDefine(t,s){const o=t.trimEnd()+" ",e=this.options.defines.findIndex(i=>i===t||i.startsWith(o));return e>=0&&this.options.defines.splice(e,1),(typeof s!="boolean"||s)&&this.options.defines.push(o+s),this}isReadyForSubMesh(t,s,o){return this.isReady(t,o,s)}isReady(t,s,o){const e=o&&this._storeEffectOnSubMeshes;if(this.isFrozen){const h=e?o._drawWrapper:this._drawWrapper;if(h.effect&&h._wasPreviouslyReady&&h._wasPreviouslyUsingInstances===s)return!0}const i=this.getScene(),n=i.getEngine(),a=[],f=[];let c=null,g=this._shaderPath,r=this._options.uniforms,u=this._options.uniformBuffers,p=this._options.samplers;n.getCaps().multiview&&i.activeCamera&&i.activeCamera.outputRenderTarget&&i.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,a.push("#define MULTIVIEW"),r.indexOf("viewProjection")!==-1&&r.indexOf("viewProjectionR")===-1&&r.push("viewProjectionR"));for(let h=0;h<this._options.defines.length;h++){const T=this._options.defines[h].indexOf("#define")===0?this._options.defines[h]:`#define ${this._options.defines[h]}`;a.push(T)}for(let h=0;h<this._options.attributes.length;h++)f.push(this._options.attributes[h]);if(t&&t.isVerticesDataPresent(l.ColorKind)&&(f.indexOf(l.ColorKind)===-1&&f.push(l.ColorKind),a.push("#define VERTEXCOLOR")),s&&(a.push("#define INSTANCES"),I(f,this._materialHelperNeedsPreviousMatrices),t?.hasThinInstances&&(a.push("#define THIN_INSTANCES"),t&&t.isVerticesDataPresent(l.ColorInstanceKind)&&(f.push(l.ColorInstanceKind),a.push("#define INSTANCESCOLOR")))),t&&t.useBones&&t.computeBonesUsingShaders&&t.skeleton){f.push(l.MatricesIndicesKind),f.push(l.MatricesWeightsKind),t.numBoneInfluencers>4&&(f.push(l.MatricesIndicesExtraKind),f.push(l.MatricesWeightsExtraKind));const h=t.skeleton;a.push("#define NUM_BONE_INFLUENCERS "+t.numBoneInfluencers),c=new H,c.addCPUSkinningFallback(0,t),h.isUsingTextureForMatrices?(a.push("#define BONETEXTURE"),r.indexOf("boneTextureWidth")===-1&&r.push("boneTextureWidth"),this._options.samplers.indexOf("boneSampler")===-1&&this._options.samplers.push("boneSampler")):(a.push("#define BonesPerMesh "+(h.bones.length+1)),r.indexOf("mBones")===-1&&r.push("mBones"))}else a.push("#define NUM_BONE_INFLUENCERS 0");let d=0;const y=t?t.morphTargetManager:null;if(y){const h=a.indexOf("#define UV1")!==-1,T=a.indexOf("#define UV2")!==-1,w=a.indexOf("#define TANGENT")!==-1,U=a.indexOf("#define NORMAL")!==-1,C=a.indexOf("#define VERTEXCOLOR")!==-1;d=N(y,a,f,t,!0,U,w,h,T,C),y.isUsingTextureForTargets&&(r.indexOf("morphTargetTextureIndices")===-1&&r.push("morphTargetTextureIndices"),this._options.samplers.indexOf("morphTargets")===-1&&this._options.samplers.push("morphTargets")),d>0&&(r=r.slice(),r.push("morphTargetInfluences"),r.push("morphTargetCount"),r.push("morphTargetTextureInfo"),r.push("morphTargetTextureIndices"))}else a.push("#define NUM_MORPH_INFLUENCERS 0");if(t){const h=t.bakedVertexAnimationManager;h&&h.isEnabled&&(a.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),r.indexOf("bakedVertexAnimationSettings")===-1&&r.push("bakedVertexAnimationSettings"),r.indexOf("bakedVertexAnimationTextureSizeInverted")===-1&&r.push("bakedVertexAnimationTextureSizeInverted"),r.indexOf("bakedVertexAnimationTime")===-1&&r.push("bakedVertexAnimationTime"),this._options.samplers.indexOf("bakedVertexAnimationTexture")===-1&&this._options.samplers.push("bakedVertexAnimationTexture")),F(f,t,a)}for(const h in this._textures)if(!this._textures[h].isReady())return!1;t&&this.needAlphaTestingForMesh(t)&&a.push("#define ALPHATEST"),this._options.useClipPlane!==!1&&(R(r),q(this,i,a)),i.fogEnabled&&t?.applyFog&&i.fogMode!==j.FOGMODE_NONE&&(a.push("#define FOG"),r.indexOf("view")===-1&&r.push("view"),r.indexOf("vFogInfos")===-1&&r.push("vFogInfos"),r.indexOf("vFogColor")===-1&&r.push("vFogColor")),this._useLogarithmicDepth&&(a.push("#define LOGARITHMICDEPTH"),r.indexOf("logarithmicDepthConstant")===-1&&r.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(r=r.slice(),u=u.slice(),p=p.slice(),g=this.customShaderNameResolve(this.name,r,u,p,a,f));const _=o?o.getRenderingMesh():t;if(_&&this.useVertexPulling){a.push("#define USE_VERTEX_PULLING");const h=_.geometry?.getIndexBuffer();h&&(a.push("#define VERTEX_PULLING_USE_INDEX_BUFFER"),h.is32Bits&&a.push("#define VERTEX_PULLING_INDEX_BUFFER_32BITS"))}const A=e?o._getDrawWrapper(void 0,!0):this._drawWrapper,O=A?.effect??null,B=A?.defines??null,v=a.join(`
`);let m=O;return B!==v&&(m=n.createEffect(g,{attributes:f,uniformsNames:r,uniformBuffersNames:u,samplers:p,defines:v,fallbacks:c,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:d},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},n),e?o.setEffect(m,v,this._materialContext):A&&A.setEffect(m,v),this._onEffectCreatedObservable&&(b.effect=m,b.subMesh=o??t?.subMeshes[0]??null,this._onEffectCreatedObservable.notifyObservers(b))),A._wasPreviouslyUsingInstances=!!s,m?.isReady()?(O!==m&&i.resetCachedMaterial(),A._wasPreviouslyReady=!0,!0):!1}bindOnlyWorldMatrix(t,s){const o=s??this.getEffect();if(!o)return;const e=this._options.uniforms;e.indexOf("world")!==-1&&o.setMatrix("world",t);const i=this.getScene();e.indexOf("worldView")!==-1&&(t.multiplyToRef(i.getViewMatrix(),this._cachedWorldViewMatrix),o.setMatrix("worldView",this._cachedWorldViewMatrix)),e.indexOf("worldViewProjection")!==-1&&(t.multiplyToRef(i.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),o.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),e.indexOf("view")!==-1&&o.setMatrix("view",i.getViewMatrix())}bindForSubMesh(t,s,o){this.bind(t,s,o._drawWrapperOverride?.effect,o)}bind(t,s,o,e){const i=e&&this._storeEffectOnSubMeshes,n=o??(i?e.effect:this.getEffect());if(!n)return;const a=this.getScene();this._activeEffect=n,this.bindOnlyWorldMatrix(t,o);const f=this._options.uniformBuffers;let c=!1;if(n&&f&&f.length>0&&a.getEngine().supportsUniformBuffers)for(let r=0;r<f.length;++r)switch(f[r]){case"Mesh":s&&(s.getMeshUniformBuffer().bindToEffect(n,"Mesh"),s.transferToEffect(t));break;case"Scene":L(n,a.getSceneUniformBuffer()),a.finalizeSceneUbo(),c=!0;break}const g=s&&i?this._mustRebind(a,n,e,s.visibility):a.getCachedMaterial()!==this;if(n&&g){!c&&this._options.uniforms.indexOf("view")!==-1&&n.setMatrix("view",a.getViewMatrix()),!c&&this._options.uniforms.indexOf("projection")!==-1&&n.setMatrix("projection",a.getProjectionMatrix()),!c&&this._options.uniforms.indexOf("viewProjection")!==-1&&(n.setMatrix("viewProjection",a.getTransformMatrix()),this._multiview&&n.setMatrix("viewProjectionR",a._transformMatrixR)),a.activeCamera&&this._options.uniforms.indexOf("cameraPosition")!==-1&&n.setVector3("cameraPosition",a.activeCamera.globalPosition),W(s,n),z(n,this,a),this._useLogarithmicDepth&&D(i?e.materialDefines:n.defines,n,a),s&&G(a,s,n);let r;for(r in this._textures)n.setTexture(r,this._textures[r]);for(r in this._textureArrays)n.setTextureArray(r,this._textureArrays[r]);for(r in this._ints)n.setInt(r,this._ints[r]);for(r in this._uints)n.setUInt(r,this._uints[r]);for(r in this._floats)n.setFloat(r,this._floats[r]);for(r in this._floatsArrays)n.setArray(r,this._floatsArrays[r]);for(r in this._colors3)n.setColor3(r,this._colors3[r]);for(r in this._colors3Arrays)n.setArray3(r,this._colors3Arrays[r]);for(r in this._colors4){const _=this._colors4[r];n.setFloat4(r,_.r,_.g,_.b,_.a)}for(r in this._colors4Arrays)n.setArray4(r,this._colors4Arrays[r]);for(r in this._vectors2)n.setVector2(r,this._vectors2[r]);for(r in this._vectors3)n.setVector3(r,this._vectors3[r]);for(r in this._vectors4)n.setVector4(r,this._vectors4[r]);for(r in this._quaternions)n.setQuaternion(r,this._quaternions[r]);for(r in this._matrices)n.setMatrix(r,this._matrices[r]);for(r in this._matrixArrays)n.setMatrices(r,this._matrixArrays[r]);for(r in this._matrices3x3)n.setMatrix3x3(r,this._matrices3x3[r]);for(r in this._matrices2x2)n.setMatrix2x2(r,this._matrices2x2[r]);for(r in this._vectors2Arrays)n.setArray2(r,this._vectors2Arrays[r]);for(r in this._vectors3Arrays)n.setArray3(r,this._vectors3Arrays[r]);for(r in this._vectors4Arrays)n.setArray4(r,this._vectors4Arrays[r]);for(r in this._quaternionsArrays)n.setArray4(r,this._quaternionsArrays[r]);for(r in this._uniformBuffers){const _=this._uniformBuffers[r].getBuffer();_&&n.bindUniformBuffer(_,r)}const u=a.getEngine(),p=u.setExternalTexture;if(p)for(r in this._externalTextures)p.call(u,r,this._externalTextures[r]);const d=u.setTextureSampler;if(d)for(r in this._textureSamplers)d.call(u,r,this._textureSamplers[r]);const y=u.setStorageBuffer;if(y)for(r in this._storageBuffers)y.call(u,r,this._storageBuffers[r])}if(n&&s&&(g||!this.isFrozen)){K(s,n),s.morphTargetManager&&s.morphTargetManager.isUsingTextureForTargets&&s.morphTargetManager._bind(n);const r=s.bakedVertexAnimationManager;if(r&&r.isEnabled){const u=i?e._drawWrapper:this._drawWrapper;s.bakedVertexAnimationManager?.bind(n,!!u._wasPreviouslyUsingInstances)}}this._afterBind(s,n,e)}getActiveTextures(){const t=super.getActiveTextures();for(const s in this._textures)t.push(this._textures[s]);for(const s in this._textureArrays){const o=this._textureArrays[s];for(let e=0;e<o.length;e++)t.push(o[e])}return t}hasTexture(t){if(super.hasTexture(t))return!0;for(const s in this._textures)if(this._textures[s]===t)return!0;for(const s in this._textureArrays){const o=this._textureArrays[s];for(let e=0;e<o.length;e++)if(o[e]===t)return!0}return!1}clone(t){const s=E.Clone(()=>new x(t,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes),this);s.name=t,s.id=t,typeof s._shaderPath=="object"&&(s._shaderPath={...s._shaderPath}),this._options={...this._options};const o=Object.keys(this._options);for(const e of o){const i=this._options[e];Array.isArray(i)&&(this._options[e]=i.slice(0))}this.stencil.copyTo(s.stencil);for(const e in this._textures)s.setTexture(e,this._textures[e]);for(const e in this._textureArrays)s.setTextureArray(e,this._textureArrays[e]);for(const e in this._externalTextures)s.setExternalTexture(e,this._externalTextures[e]);for(const e in this._ints)s.setInt(e,this._ints[e]);for(const e in this._uints)s.setUInt(e,this._uints[e]);for(const e in this._floats)s.setFloat(e,this._floats[e]);for(const e in this._floatsArrays)s.setFloats(e,this._floatsArrays[e]);for(const e in this._colors3)s.setColor3(e,this._colors3[e]);for(const e in this._colors3Arrays)s._colors3Arrays[e]=this._colors3Arrays[e];for(const e in this._colors4)s.setColor4(e,this._colors4[e]);for(const e in this._colors4Arrays)s._colors4Arrays[e]=this._colors4Arrays[e];for(const e in this._vectors2)s.setVector2(e,this._vectors2[e]);for(const e in this._vectors3)s.setVector3(e,this._vectors3[e]);for(const e in this._vectors4)s.setVector4(e,this._vectors4[e]);for(const e in this._quaternions)s.setQuaternion(e,this._quaternions[e]);for(const e in this._quaternionsArrays)s._quaternionsArrays[e]=this._quaternionsArrays[e];for(const e in this._matrices)s.setMatrix(e,this._matrices[e]);for(const e in this._matrixArrays)s._matrixArrays[e]=this._matrixArrays[e].slice();for(const e in this._matrices3x3)s.setMatrix3x3(e,this._matrices3x3[e]);for(const e in this._matrices2x2)s.setMatrix2x2(e,this._matrices2x2[e]);for(const e in this._vectors2Arrays)s.setArray2(e,this._vectors2Arrays[e]);for(const e in this._vectors3Arrays)s.setArray3(e,this._vectors3Arrays[e]);for(const e in this._vectors4Arrays)s.setArray4(e,this._vectors4Arrays[e]);for(const e in this._uniformBuffers)s.setUniformBuffer(e,this._uniformBuffers[e]);for(const e in this._textureSamplers)s.setTextureSampler(e,this._textureSamplers[e]);for(const e in this._storageBuffers)s.setStorageBuffer(e,this._storageBuffers[e]);return s}dispose(t,s,o){if(s){let e;for(e in this._textures)this._textures[e].dispose();for(e in this._textureArrays){const i=this._textureArrays[e];for(let n=0;n<i.length;n++)i[n].dispose()}}this._textures={},super.dispose(t,s,o)}serialize(){const t=E.Serialize(this);t.customType="BABYLON.ShaderMaterial",t.uniqueId=this.uniqueId,t.options=this._options,t.shaderPath=this._shaderPath,t.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes;let s;t.stencil=this.stencil.serialize(),t.textures={};for(s in this._textures)t.textures[s]=this._textures[s].serialize();t.textureArrays={};for(s in this._textureArrays){t.textureArrays[s]=[];const o=this._textureArrays[s];for(let e=0;e<o.length;e++)t.textureArrays[s].push(o[e].serialize())}t.ints={};for(s in this._ints)t.ints[s]=this._ints[s];t.uints={};for(s in this._uints)t.uints[s]=this._uints[s];t.floats={};for(s in this._floats)t.floats[s]=this._floats[s];t.floatsArrays={};for(s in this._floatsArrays)t.floatsArrays[s]=this._floatsArrays[s];t.colors3={};for(s in this._colors3){const o=this._colors3[s];t.colors3[s]=[o.r,o.g,o.b]}t.colors3Arrays={};for(s in this._colors3Arrays)t.colors3Arrays[s]=this._colors3Arrays[s];t.colors4={};for(s in this._colors4){const o=this._colors4[s];t.colors4[s]=[o.r,o.g,o.b,o.a]}t.colors4Arrays={};for(s in this._colors4Arrays)t.colors4Arrays[s]=this._colors4Arrays[s];t.vectors2={};for(s in this._vectors2){const o=this._vectors2[s];t.vectors2[s]=[o.x,o.y]}t.vectors3={};for(s in this._vectors3){const o=this._vectors3[s];t.vectors3[s]=[o.x,o.y,o.z]}t.vectors4={};for(s in this._vectors4){const o=this._vectors4[s];t.vectors4[s]=[o.x,o.y,o.z,o.w]}t.quaternions={};for(s in this._quaternions)t.quaternions[s]=this._quaternions[s].asArray();t.matrices={};for(s in this._matrices)t.matrices[s]=this._matrices[s].asArray();t.matrixArray={};for(s in this._matrixArrays)t.matrixArray[s]=this._matrixArrays[s];t.matrices3x3={};for(s in this._matrices3x3)t.matrices3x3[s]=this._matrices3x3[s];t.matrices2x2={};for(s in this._matrices2x2)t.matrices2x2[s]=this._matrices2x2[s];t.vectors2Arrays={};for(s in this._vectors2Arrays)t.vectors2Arrays[s]=this._vectors2Arrays[s];t.vectors3Arrays={};for(s in this._vectors3Arrays)t.vectors3Arrays[s]=this._vectors3Arrays[s];t.vectors4Arrays={};for(s in this._vectors4Arrays)t.vectors4Arrays[s]=this._vectors4Arrays[s];t.quaternionsArrays={};for(s in this._quaternionsArrays)t.quaternionsArrays[s]=this._quaternionsArrays[s];return t}static Parse(t,s,o){const e=E.Parse(()=>new x(t.name,s,t.shaderPath,t.options,t.storeEffectOnSubMeshes),t,s,o);let i;t.stencil&&e.stencil.parse(t.stencil,s,o);for(i in t.textures)e.setTexture(i,S.Parse(t.textures[i],s,o));for(i in t.textureArrays){const n=t.textureArrays[i],a=[];for(let f=0;f<n.length;f++)a.push(S.Parse(n[f],s,o));e.setTextureArray(i,a)}for(i in t.ints)e.setInt(i,t.ints[i]);for(i in t.uints)e.setUInt(i,t.uints[i]);for(i in t.floats)e.setFloat(i,t.floats[i]);for(i in t.floatsArrays)e.setFloats(i,t.floatsArrays[i]);for(i in t.colors3){const n=t.colors3[i];e.setColor3(i,{r:n[0],g:n[1],b:n[2]})}for(i in t.colors3Arrays){const n=t.colors3Arrays[i].reduce((a,f,c)=>(c%3===0?a.push([f]):a[a.length-1].push(f),a),[]).map(a=>({r:a[0],g:a[1],b:a[2]}));e.setColor3Array(i,n)}for(i in t.colors4){const n=t.colors4[i];e.setColor4(i,{r:n[0],g:n[1],b:n[2],a:n[3]})}for(i in t.colors4Arrays){const n=t.colors4Arrays[i].reduce((a,f,c)=>(c%4===0?a.push([f]):a[a.length-1].push(f),a),[]).map(a=>({r:a[0],g:a[1],b:a[2],a:a[3]}));e.setColor4Array(i,n)}for(i in t.vectors2){const n=t.vectors2[i];e.setVector2(i,{x:n[0],y:n[1]})}for(i in t.vectors3){const n=t.vectors3[i];e.setVector3(i,{x:n[0],y:n[1],z:n[2]})}for(i in t.vectors4){const n=t.vectors4[i];e.setVector4(i,{x:n[0],y:n[1],z:n[2],w:n[3]})}for(i in t.quaternions)e.setQuaternion(i,X.FromArray(t.quaternions[i]));for(i in t.matrices)e.setMatrix(i,M.FromArray(t.matrices[i]));for(i in t.matrixArray)e._matrixArrays[i]=new Float32Array(t.matrixArray[i]);for(i in t.matrices3x3)e.setMatrix3x3(i,t.matrices3x3[i]);for(i in t.matrices2x2)e.setMatrix2x2(i,t.matrices2x2[i]);for(i in t.vectors2Arrays)e.setArray2(i,t.vectors2Arrays[i]);for(i in t.vectors3Arrays)e.setArray3(i,t.vectors3Arrays[i]);for(i in t.vectors4Arrays)e.setArray4(i,t.vectors4Arrays[i]);for(i in t.quaternionsArrays)e.setArray4(i,t.quaternionsArrays[i]);return e}static async ParseFromFileAsync(t,s,o,e=""){return await new Promise((i,n)=>{const a=new P;a.addEventListener("readystatechange",()=>{if(a.readyState==4)if(a.status==200){const f=JSON.parse(a.responseText),c=this.Parse(f,o||k.LastCreatedScene,e);t&&(c.name=t),i(c)}else n("Unable to load the ShaderMaterial")}),a.open("GET",s),a.send()})}static async ParseFromSnippetAsync(t,s,o=""){return await new Promise((e,i)=>{const n=new P;n.addEventListener("readystatechange",()=>{if(n.readyState==4)if(n.status==200){const a=JSON.parse(JSON.parse(n.responseText).jsonPayload),f=JSON.parse(a.shaderMaterial),c=this.Parse(f,s||k.LastCreatedScene,o);c.snippetId=t,e(c)}else i("Unable to load the snippet "+t)}),n.open("GET",this.SnippetUrl+"/"+t.replace(/#/g,"/")),n.send()})}}x.SnippetUrl="https://snippet.babylonjs.com";x.CreateFromSnippetAsync=x.ParseFromSnippetAsync;Q("BABYLON.ShaderMaterial",x);export{x as ShaderMaterial};
