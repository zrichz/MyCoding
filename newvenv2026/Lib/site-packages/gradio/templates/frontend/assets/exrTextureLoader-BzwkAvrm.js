import{aI as vn,L as H,e as Y}from"./index-Dtj0WP_z.js";import"./index-Dw8Uzof1.js";import"./svelte/svelte_svelte.js";import"./svelte/svelte_animate.js";import"./svelte/svelte_attachments.js";import"./svelte/svelte_easing.js";import"./svelte/svelte_internal_client.js";import"./svelte/svelte_internal_flags_async.js";import"./svelte/svelte_internal_flags_legacy.js";import"./svelte/svelte_internal_flags_tracing.js";import"./svelte/svelte_internal_server.js";import"./svelte/svelte_legacy.js";import"./svelte/svelte_motion.js";import"./svelte/svelte_reactivity.js";import"./svelte/svelte_reactivity_window.js";import"./svelte/svelte_server.js";import"./svelte/svelte_store.js";import"./svelte/svelte_transition.js";import"./svelte/svelte_events.js";const an=4,K=4,sn=1,N=2,bn=8,B=65536,d=B>>3,gn=16,T=14,D=(1<<gn)+1,j=1<<T,nn=j-1,q=59,on=63,In=2+on-q;var U;(function(n){n[n.NO_COMPRESSION=0]="NO_COMPRESSION",n[n.RLE_COMPRESSION=1]="RLE_COMPRESSION",n[n.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",n[n.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",n[n.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",n[n.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"})(U||(U={}));var $;(function(n){n[n.INCREASING_Y=0]="INCREASING_Y",n[n.DECREASING_Y=1]="DECREASING_Y"})($||($={}));const z=mn();function mn(){const n=new ArrayBuffer(4),t=new Float32Array(n),e=new Uint32Array(n),l=new Uint32Array(512),r=new Uint32Array(512);for(let a=0;a<256;++a){const i=a-127;i<-27?(l[a]=0,l[a|256]=32768,r[a]=24,r[a|256]=24):i<-14?(l[a]=1024>>-i-14,l[a|256]=1024>>-i-14|32768,r[a]=-i-1,r[a|256]=-i-1):i<=15?(l[a]=i+15<<10,l[a|256]=i+15<<10|32768,r[a]=13,r[a|256]=13):i<128?(l[a]=31744,l[a|256]=64512,r[a]=24,r[a|256]=24):(l[a]=31744,l[a|256]=64512,r[a]=13,r[a|256]=13)}const o=new Uint32Array(2048),s=new Uint32Array(64),c=new Uint32Array(64);for(let a=1;a<1024;++a){let i=a<<13,u=0;for(;(i&8388608)===0;)i<<=1,u-=8388608;i&=-8388609,u+=947912704,o[a]=i|u}for(let a=1024;a<2048;++a)o[a]=939524096+(a-1024<<13);for(let a=1;a<31;++a)s[a]=a<<23;s[31]=1199570944,s[32]=2147483648;for(let a=33;a<63;++a)s[a]=2147483648+(a-32<<23);s[63]=3347054592;for(let a=1;a<64;++a)a!==32&&(c[a]=1024);return{floatView:t,uint32View:e,baseTable:l,shiftTable:r,mantissaTable:o,exponentTable:s,offsetTable:c}}function J(n,t){const e=new Uint8Array(n);let l=0;for(;e[t.value+l]!=0;)l+=1;const r=new TextDecoder().decode(e.slice(t.value,t.value+l));return t.value=t.value+l+1,r}function P(n,t){const e=n.getInt32(t.value,!0);return t.value+=an,e}function R(n,t){const e=n.getUint32(t.value,!0);return t.value+=an,e}function W(n,t){const e=n.getUint8(t.value);return t.value+=sn,e}function Z(n,t){const e=n.getUint16(t.value,!0);return t.value+=N,e}function cn(n,t){const e=n[t.value];return t.value+=sn,e}function An(n,t){let e;return"getBigInt64"in DataView.prototype?e=Number(n.getBigInt64(t.value,!0)):e=n.getUint32(t.value+4,!0)+Number(n.getUint32(t.value,!0)<<32),t.value+=bn,e}function b(n,t){const e=n.getFloat32(t.value,!0);return t.value+=K,e}function On(n,t){return Pn(Z(n,t))}function Pn(n){const t=(n&31744)>>10,e=n&1023;return(n>>15?-1:1)*(t?t===31?e?NaN:1/0:Math.pow(2,t-15)*(1+e/1024):6103515625e-14*(e/1024))}function Un(n){if(Math.abs(n)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");n=vn(n,-65504,65504),z.floatView[0]=n;const t=z.uint32View[0],e=t>>23&511;return z.baseTable[e]+((t&8388607)>>z.shiftTable[e])}function Rn(n,t){return Un(b(n,t))}function Tn(n,t,e){const l=new TextDecoder().decode(new Uint8Array(n).slice(t.value,t.value+e));return t.value=t.value+e,l}function Cn(n,t){const e=P(n,t),l=R(n,t);return[e,l]}function _n(n,t){const e=R(n,t),l=R(n,t);return[e,l]}function Nn(n,t){const e=b(n,t),l=b(n,t);return[e,l]}function Mn(n,t){const e=b(n,t),l=b(n,t),r=b(n,t);return[e,l,r]}function Fn(n,t,e){const l=t.value,r=[];for(;t.value<l+e-1;){const o=J(n.buffer,t),s=P(n,t),c=W(n,t);t.value+=3;const a=P(n,t),i=P(n,t);r.push({name:o,pixelType:s,pLinear:c,xSampling:a,ySampling:i})}return t.value+=1,r}function Dn(n,t){const e=b(n,t),l=b(n,t),r=b(n,t),o=b(n,t),s=b(n,t),c=b(n,t),a=b(n,t),i=b(n,t);return{redX:e,redY:l,greenX:r,greenY:o,blueX:s,blueY:c,whiteX:a,whiteY:i}}function kn(n,t){return W(n,t)}function Ln(n,t){const e=P(n,t),l=P(n,t),r=P(n,t),o=P(n,t);return{xMin:e,yMin:l,xMax:r,yMax:o}}function zn(n,t){const e=W(n,t);return $[e]}function Hn(n,t,e,l){switch(e){case"string":case"stringvector":case"iccProfile":return Tn(n.buffer,t,l);case"chlist":return Fn(n,t,l);case"chromaticities":return Dn(n,t);case"compression":return kn(n,t);case"box2i":return Ln(n,t);case"lineOrder":return zn(n,t);case"float":return b(n,t);case"v2f":return Nn(n,t);case"v3f":return Mn(n,t);case"int":return P(n,t);case"rational":return Cn(n,t);case"timecode":return _n(n,t);case"preview":return t.value+=l,"skipped";default:t.value+=l;return}}function un(n){for(let t=1;t<n.length;t++){const e=n[t-1]+n[t]-128;n[t]=e}}function pn(n,t){let e=0,l=Math.floor((n.length+1)/2),r=0;const o=n.length-1;for(;!(r>o||(t[r++]=n[e++],r>o));)t[r++]=n[l++]}const Bn=20000630;function hn(n,t){if(n.getUint32(0,!0)!=Bn)throw new Error("Incorrect OpenEXR format");const e=n.getUint8(4),l=n.getUint8(5),r={singleTile:!!(l&2),longName:!!(l&4),deepFormat:!!(l&8),multiPart:!!(l&16)};t.value=8;const o={};let s=!0;for(;s;){const c=J(n.buffer,t);if(!c)s=!1;else{const a=J(n.buffer,t),i=R(n,t),u=Hn(n,t,a,i);u===void 0?H.Warn(`Unknown header attribute type ${a}'.`):o[c]=u}}if((l&-5)!=0)throw new Error("Unsupported file format");return{version:e,spec:r,...o}}const fn=16,Zn=1<<fn-1,tn=(1<<fn)-1;function Wn(n,t){let e=0;for(let r=0;r<B;++r)(r==0||n[r>>3]&1<<(r&7))&&(t[e++]=r);const l=e-1;for(;e<B;)t[e++]=0;return l}function Gn(n){for(let t=0;t<j;t++)n[t]={},n[t].len=0,n[t].lit=0,n[t].p=null}function en(n,t,e,l,r){for(;e<n;)t=t<<8|cn(l,r),e+=8;return e-=n,{l:t>>e&(1<<n)-1,c:t,lc:e}}function Q(n,t,e,l){return n=n<<8|cn(e,l),t+=8,{c:n,lc:t}}function X(n,t,e,l,r,o,s,c,a){if(n==t){if(l<8){const h=Q(e,l,r,o);e=h.c,l=h.lc}l-=8;let i=e>>l;if(i=new Uint8Array([i])[0],c.value+i>a)return null;const u=s[c.value-1];for(;i-- >0;)s[c.value++]=u}else if(c.value<a)s[c.value++]=n;else return null;return{c:e,lc:l}}const F=new Array(59);function Yn(n){for(let e=0;e<=58;++e)F[e]=0;for(let e=0;e<D;++e)F[n[e]]+=1;let t=0;for(let e=58;e>0;--e){const l=t+F[e]>>1;F[e]=t,t=l}for(let e=0;e<D;++e){const l=n[e];l>0&&(n[e]=l|F[l]++<<6)}}function Xn(n,t,e,l,r,o){const s=t;let c=0,a=0;for(;l<=r;l++){if(s.value-t.value>e)return;let i=en(6,c,a,n,s);const u=i.l;if(c=i.c,a=i.lc,o[l]=u,u==on){if(s.value-t.value>e)throw new Error("Error in HufUnpackEncTable");i=en(8,c,a,n,s);let h=i.l+In;if(c=i.c,a=i.lc,l+h>r+1)throw new Error("Error in HufUnpackEncTable");for(;h--;)o[l++]=0;l--}else if(u>=q){let h=u-q+2;if(l+h>r+1)throw new Error("Error in HufUnpackEncTable");for(;h--;)o[l++]=0;l--}}Yn(o)}function wn(n){return n&63}function yn(n){return n>>6}function Kn(n,t,e,l){for(;t<=e;t++){const r=yn(n[t]),o=wn(n[t]);if(r>>o)throw new Error("Invalid table entry");if(o>T){const s=l[r>>o-T];if(s.len)throw new Error("Invalid table entry");if(s.lit++,s.p){const c=s.p;s.p=new Array(s.lit);for(let a=0;a<s.lit-1;++a)s.p[a]=c[a]}else s.p=new Array(1);s.p[s.lit-1]=t}else if(o){let s=0;for(let c=1<<T-o;c>0;c--){const a=l[(r<<T-o)+s];if(a.len||a.p)throw new Error("Invalid table entry");a.len=o,a.lit=t,s++}}}return!0}function qn(n,t,e,l,r,o,s,c,a){let i=0,u=0;const h=s,x=Math.trunc(l.value+(r+7)/8);for(;l.value<x;){let p=Q(i,u,e,l);for(i=p.c,u=p.lc;u>=T;){const w=i>>u-T&nn,y=t[w];if(y.len){u-=y.len;const f=X(y.lit,o,i,u,e,l,c,a,h);f&&(i=f.c,u=f.lc)}else{if(!y.p)throw new Error("hufDecode issues");let f;for(f=0;f<y.lit;f++){const v=wn(n[y.p[f]]);for(;u<v&&l.value<x;)p=Q(i,u,e,l),i=p.c,u=p.lc;if(u>=v&&yn(n[y.p[f]])==(i>>u-v&(1<<v)-1)){u-=v;const A=X(y.p[f],o,i,u,e,l,c,a,h);A&&(i=A.c,u=A.lc);break}}if(f==y.lit)throw new Error("HufDecode issues")}}}const I=8-r&7;for(i>>=I,u-=I;u>0;){const p=t[i<<T-u&nn];if(p.len){u-=p.len;const w=X(p.lit,o,i,u,e,l,c,a,h);w&&(i=w.c,u=w.lc)}else throw new Error("HufDecode issues")}return!0}function $n(n,t,e,l,r,o){const s={value:0},c=e.value,a=R(t,e),i=R(t,e);e.value+=4;const u=R(t,e);if(e.value+=4,a<0||a>=D||i<0||i>=D)throw new Error("Wrong HUF_ENCSIZE");const h=new Array(D),x=new Array(j);Gn(x);const I=l-(e.value-c);if(Xn(n,e,I,a,i,h),u>8*(l-(e.value-c)))throw new Error("Wrong hufUncompress");Kn(h,a,i,x),qn(h,x,n,e,u,i,o,r,s)}function V(n){return n&65535}function rn(n){const t=V(n);return t>32767?t-65536:t}function C(n,t){const e=rn(n),r=rn(t),o=e+(r&1)+(r>>1),s=o,c=o-r;return{a:s,b:c}}function _(n,t){const e=V(n),l=V(t),r=e-(l>>1)&tn;return{a:l+r-Zn&tn,b:r}}function Jn(n,t,e,l,r,o,s){const c=s<16384,a=e>r?r:e;let i=1,u,h;for(;i<=a;)i<<=1;for(i>>=1,u=i,i>>=1;i>=1;){h=0;const x=h+o*(r-u),I=o*i,p=o*u,w=l*i,y=l*u;let f,v,A,k;for(;h<=x;h+=p){let S=h;const G=h+l*(e-u);for(;S<=G;S+=y){const m=S+w,g=S+I,L=g+w;if(c){let E=C(n[S+t],n[g+t]);f=E.a,A=E.b,E=C(n[m+t],n[L+t]),v=E.a,k=E.b,E=C(f,v),n[S+t]=E.a,n[m+t]=E.b,E=C(A,k),n[g+t]=E.a,n[L+t]=E.b}else{let E=_(n[S+t],n[g+t]);f=E.a,A=E.b,E=_(n[m+t],n[L+t]),v=E.a,k=E.b,E=_(f,v),n[S+t]=E.a,n[m+t]=E.b,E=_(A,k),n[g+t]=E.a,n[L+t]=E.b}}if(e&i){const m=S+I;let g;c?g=C(n[S+t],n[m+t]):g=_(n[S+t],n[m+t]),f=g.a,n[m+t]=g.b,n[S+t]=f}}if(r&i){let S=h;const G=h+l*(e-u);for(;S<=G;S+=y){const m=S+w;let g;c?g=C(n[S+t],n[m+t]):g=_(n[S+t],n[m+t]),f=g.a,n[m+t]=g.b,n[S+t]=f}}u=i,i>>=1}return h}function Qn(n,t,e){for(let l=0;l<e;++l)t[l]=n[t[l]]}function Vn(n){let t=n.byteLength;const e=[];let l=0;const r=new DataView(n);for(;t>0;){const o=r.getInt8(l++);if(o<0){const s=-o;t-=s+1;for(let c=0;c<s;c++)e.push(r.getUint8(l++))}else{const s=o;t-=2;const c=r.getUint8(l++);for(let a=0;a<s+1;a++)e.push(c)}}return e}function En(n){return new DataView(n.array.buffer,n.offset.value,n.size)}function jn(n){const t=n.viewer.buffer.slice(n.offset.value,n.offset.value+n.size),e=new Uint8Array(Vn(t)),l=new Uint8Array(e.length);return un(e),pn(e,l),new DataView(l.buffer)}function ln(n){const t=n.array.slice(n.offset.value,n.offset.value+n.size),e=fflate.unzlibSync(t),l=new Uint8Array(e.length);return un(e),pn(e,l),new DataView(l.buffer)}function dn(n){const t=n.array.slice(n.offset.value,n.offset.value+n.size),e=fflate.unzlibSync(t),l=n.lines*n.channels*n.width,r=n.type==1?new Uint16Array(l):new Uint32Array(l);let o=0,s=0;const c=new Array(4);for(let a=0;a<n.lines;a++)for(let i=0;i<n.channels;i++){let u=0;switch(n.type){case 1:c[0]=o,c[1]=c[0]+n.width,o=c[1]+n.width;for(let h=0;h<n.width;++h){const x=e[c[0]++]<<8|e[c[1]++];u+=x,r[s]=u,s++}break;case 2:c[0]=o,c[1]=c[0]+n.width,c[2]=c[1]+n.width,o=c[2]+n.width;for(let h=0;h<n.width;++h){const x=e[c[0]++]<<24|e[c[1]++]<<16|e[c[2]++]<<8;u+=x,r[s]=u,s++}break}}return new DataView(r.buffer)}function nt(n){const t=n.viewer,e={value:n.offset.value},l=new Uint16Array(n.width*n.scanlineBlockSize*(n.channels*n.type)),r=new Uint8Array(d);let o=0;const s=new Array(n.channels);for(let p=0;p<n.channels;p++)s[p]={},s[p].start=o,s[p].end=s[p].start,s[p].nx=n.width,s[p].ny=n.lines,s[p].size=n.type,o+=s[p].nx*s[p].ny*s[p].size;const c=Z(t,e),a=Z(t,e);if(a>=d)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(c<=a)for(let p=0;p<a-c+1;p++)r[p+c]=W(t,e);const i=new Uint16Array(B),u=Wn(r,i),h=R(t,e);$n(n.array,t,e,h,l,o);for(let p=0;p<n.channels;++p){const w=s[p];for(let y=0;y<s[p].size;++y)Jn(l,w.start+y,w.nx,w.size,w.ny,w.nx*w.size,u)}Qn(i,l,o);let x=0;const I=new Uint8Array(l.buffer.byteLength);for(let p=0;p<n.lines;p++)for(let w=0;w<n.channels;w++){const y=s[w],f=y.nx*y.size,v=new Uint8Array(l.buffer,y.end*N,f*N);I.set(v,x),x+=f*N,y.end+=f}return new DataView(I.buffer)}var O;(function(n){n[n.Float=0]="Float",n[n.HalfFloat=1]="HalfFloat"})(O||(O={}));class M{}M.DefaultOutputType=O.HalfFloat;M.FFLATEUrl="https://unpkg.com/fflate@0.8.2";async function Sn(n,t,e,l){const r={size:0,viewer:t,array:new Uint8Array(t.buffer),offset:e,width:n.dataWindow.xMax-n.dataWindow.xMin+1,height:n.dataWindow.yMax-n.dataWindow.yMin+1,channels:n.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(n.compression){case U.NO_COMPRESSION:r.lines=1,r.uncompress=En;break;case U.RLE_COMPRESSION:r.lines=1,r.uncompress=jn;break;case U.ZIPS_COMPRESSION:r.lines=1,r.uncompress=ln,await Y.LoadScriptAsync(M.FFLATEUrl);break;case U.ZIP_COMPRESSION:r.lines=16,r.uncompress=ln,await Y.LoadScriptAsync(M.FFLATEUrl);break;case U.PIZ_COMPRESSION:r.lines=32,r.uncompress=nt;break;case U.PXR24_COMPRESSION:r.lines=16,r.uncompress=dn,await Y.LoadScriptAsync(M.FFLATEUrl);break;default:throw new Error(U[n.compression]+" is unsupported")}r.scanlineBlockSize=r.lines;const o={};for(const i of n.channels)switch(i.name){case"R":case"G":case"B":case"A":o[i.name]=!0,r.type=i.pixelType;break;case"Y":o[i.name]=!0,r.type=i.pixelType;break}let s=!1;if(o.R&&o.G&&o.B&&o.A)r.outputChannels=4,r.decodeChannels={R:0,G:1,B:2,A:3};else if(o.R&&o.G&&o.B)s=!0,r.outputChannels=4,r.decodeChannels={R:0,G:1,B:2,A:3};else if(o.R&&o.G)r.outputChannels=2,r.decodeChannels={R:0,G:1};else if(o.R)r.outputChannels=1,r.decodeChannels={R:0};else if(o.Y)r.outputChannels=1,r.decodeChannels={Y:0};else throw new Error("EXRLoader.parse: file contains unsupported data channels.");if(r.type===1)switch(l){case O.Float:r.getter=On,r.inputSize=N;break;case O.HalfFloat:r.getter=Z,r.inputSize=N;break}else if(r.type===2)switch(l){case O.Float:r.getter=b,r.inputSize=K;break;case O.HalfFloat:r.getter=Rn,r.inputSize=K}else throw new Error("Unsupported pixelType "+r.type+" for "+n.compression);r.blockCount=r.height/r.scanlineBlockSize;for(let i=0;i<r.blockCount;i++)An(t,e);const c=r.width*r.height*r.outputChannels;switch(l){case O.Float:r.byteArray=new Float32Array(c),r.textureType=1,s&&r.byteArray.fill(1,0,c);break;case O.HalfFloat:r.byteArray=new Uint16Array(c),r.textureType=2,s&&r.byteArray.fill(15360,0,c);break;default:throw new Error("Unsupported type: "+l)}let a=0;for(const i of n.channels)r.decodeChannels[i.name]!==void 0&&(r.channelLineOffsets[i.name]=a*r.width),a+=i.pixelType*2;return r.bytesPerLine=r.width*a,r.outLineWidth=r.width*r.outputChannels,n.lineOrder==="INCREASING_Y"?r.scanOrder=i=>i:r.scanOrder=i=>r.height-1-i,r.outputChannels==4?(r.format=5,r.linearSpace=!0):(r.format=6,r.linearSpace=!1),r}function xn(n,t,e,l){const r={value:0};for(let o=0;o<n.height/n.scanlineBlockSize;o++){const s=P(e,l)-t.dataWindow.yMin;n.size=R(e,l),n.lines=s+n.scanlineBlockSize>n.height?n.height-s:n.scanlineBlockSize;const a=n.size<n.lines*n.bytesPerLine&&n.uncompress?n.uncompress(n):En(n);l.value+=n.size;for(let i=0;i<n.scanlineBlockSize;i++){const u=o*n.scanlineBlockSize,h=i+n.scanOrder(u);if(h>=n.height)continue;const x=i*n.bytesPerLine,I=(n.height-1-h)*n.outLineWidth;for(let p=0;p<n.channels;p++){const w=t.channels[p].name,y=n.channelLineOffsets[w],f=n.decodeChannels[w];if(f!==void 0){r.value=x+y;for(let v=0;v<n.width;v++){const A=I+v*n.outputChannels+f;n.byteArray&&(n.byteArray[A]=n.getter(a,r))}}}}}}class bt{constructor(){this.supportCascades=!1}loadCubeData(t,e,l,r,o){throw".exr not supported in Cube."}loadData(t,e,l){const r=new DataView(t.buffer),o={value:0},s=hn(r,o);Sn(s,r,o,M.DefaultOutputType).then(c=>{xn(c,s,r,o);const a=s.dataWindow.xMax-s.dataWindow.xMin+1,i=s.dataWindow.yMax-s.dataWindow.yMin+1;l(a,i,e.generateMipMaps,!1,()=>{const u=e.getEngine();e.format=s.format,e.type=c.textureType,e.invertY=!1,e._gammaSpace=!s.linearSpace,c.byteArray&&u._uploadDataToTextureDirectly(e,c.byteArray,0,0,void 0,!0)})}).catch(c=>{H.Error("Failed to load EXR texture: ",c)})}}async function gt(n){const t=new DataView(n),e={value:0},l=hn(t,e);try{const r=await Sn(l,t,e,O.Float);return xn(r,l,t,e),r.byteArray?{width:l.dataWindow.xMax-l.dataWindow.xMin+1,height:l.dataWindow.yMax-l.dataWindow.yMin+1,data:new Float32Array(r.byteArray)}:(H.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(r){H.Error("Failed to load EXR data: ",r)}return{width:0,height:0,data:null}}export{gt as ReadExrDataAsync,bt as _ExrTextureLoader};
