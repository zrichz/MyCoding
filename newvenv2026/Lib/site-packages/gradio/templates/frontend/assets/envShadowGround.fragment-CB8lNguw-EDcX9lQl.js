import{S as t}from"./index-Dtj0WP_z.js";import"./index-Dw8Uzof1.js";import"./svelte/svelte_svelte.js";import"./svelte/svelte_animate.js";import"./svelte/svelte_attachments.js";import"./svelte/svelte_easing.js";import"./svelte/svelte_internal_client.js";import"./svelte/svelte_internal_flags_async.js";import"./svelte/svelte_internal_flags_legacy.js";import"./svelte/svelte_internal_flags_tracing.js";import"./svelte/svelte_internal_server.js";import"./svelte/svelte_legacy.js";import"./svelte/svelte_motion.js";import"./svelte/svelte_reactivity.js";import"./svelte/svelte_reactivity_window.js";import"./svelte/svelte_server.js";import"./svelte/svelte_store.js";import"./svelte/svelte_transition.js";import"./svelte/svelte_events.js";const e="envShadowGroundPixelShader",r=`var shadowTextureSampler: sampler;var shadowTexture : texture_2d<f32>;uniform shadowOpacity : f32;uniform renderTargetSize: vec2<f32>;@fragment
fn main(input: FragmentInputs)->FragmentOutputs {let uvBasedOpacity=1.0-pow(clamp(length(input.vUV*vec2<f32>(2.0)-vec2<f32>(1.0)),0.0,1.0),2.0);let screenUv=fragmentInputs.position.xy/uniforms.renderTargetSize;let shadowValue=textureSampleLevel(shadowTexture,shadowTextureSampler,screenUv,0.0).rrr;let totalOpacity=uniforms.shadowOpacity*uvBasedOpacity;let finalShadowValue=mix(vec3<f32>(1.0),shadowValue,totalOpacity);let invertedShadowValue=vec3(1.0)-shadowValue;fragmentOutputs.color=vec4f(finalShadowValue,invertedShadowValue.r*totalOpacity);}`;t.ShadersStoreWGSL[e]||(t.ShadersStoreWGSL[e]=r);const y={name:e,shader:r};export{y as envShadowGroundPixelShaderWGSL};
