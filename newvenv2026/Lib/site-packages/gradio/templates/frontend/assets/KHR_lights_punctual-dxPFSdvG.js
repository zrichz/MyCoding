import{be as y,aP as _,V as r,M as L,aw as w,_ as b,s as A,R as v,bf as P,F as p,aN as C,aO as S}from"./index-Dtj0WP_z.js";import{a as T}from"./objectModelMapping-wn7LYZ2M.js";import{ArrayItem as m,GLTFLoader as g}from"./glTFLoader-CjRGW40y.js";import"./index-Dw8Uzof1.js";import"./svelte/svelte_svelte.js";import"./svelte/svelte_animate.js";import"./svelte/svelte_attachments.js";import"./svelte/svelte_easing.js";import"./svelte/svelte_internal_client.js";import"./svelte/svelte_internal_flags_async.js";import"./svelte/svelte_internal_flags_legacy.js";import"./svelte/svelte_internal_flags_tracing.js";import"./svelte/svelte_internal_server.js";import"./svelte/svelte_legacy.js";import"./svelte/svelte_motion.js";import"./svelte/svelte_reactivity.js";import"./svelte/svelte_reactivity_window.js";import"./svelte/svelte_server.js";import"./svelte/svelte_store.js";import"./svelte/svelte_transition.js";import"./svelte/svelte_events.js";import"./bone-DTFn1dTu.js";import"./skeleton-GWJYup5v.js";import"./rawTexture-BE3nsnOe.js";import"./assetContainer-BmMhgWSk.js";w.AddNodeConstructor("Light_Type_0",(l,t)=>()=>new c(l,r.Zero(),t));class c extends y{get shadowAngle(){return this._shadowAngle}set shadowAngle(t){this._shadowAngle=t,this.forceProjectionMatrixCompute()}get direction(){return this._direction}set direction(t){const i=this.needCube();if(this._direction=t,this.needCube()!==i&&this._shadowGenerators){const e=this._shadowGenerators.values();for(let n=e.next();n.done!==!0;n=e.next())n.value.recreateShadowMap()}}constructor(t,i,e){super(t,e),this._shadowAngle=Math.PI/2,this.position=i}getClassName(){return"PointLight"}getTypeID(){return _.LIGHTTYPEID_POINTLIGHT}needCube(){return!this.direction}getShadowDirection(t){if(this.direction)return super.getShadowDirection(t);switch(t){case 0:return new r(1,0,0);case 1:return new r(-1,0,0);case 2:return new r(0,-1,0);case 3:return new r(0,1,0);case 4:return new r(0,0,1);case 5:return new r(0,0,-1)}return r.Zero()}_setDefaultShadowProjectionMatrix(t,i,e){const n=this.getScene().activeCamera,d=this.getDepthMinZ(n),a=this.getDepthMaxZ(n),o=this.getScene().getEngine().useReverseDepthBuffer;L.PerspectiveFovLHToRef(this.shadowAngle,1,o?a:d,o?d:a,t,!0,this._scene.getEngine().isNDCHalfZRange,void 0,o)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightFalloff",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}transferToEffect(t,i){const e=this._scene.floatingOriginOffset;return this.computeTransformedInformation()?this._uniformBuffer.updateFloat4("vLightData",this.transformedPosition.x-e.x,this.transformedPosition.y-e.y,this.transformedPosition.z-e.z,0,i):this._uniformBuffer.updateFloat4("vLightData",this.position.x-e.x,this.position.y-e.y,this.position.z-e.z,0,i),this._uniformBuffer.updateFloat4("vLightFalloff",this.range,this._inverseSquaredRange,0,0,i),this}transferToNodeMaterialEffect(t,i){const e=this._scene.floatingOriginOffset;return this.computeTransformedInformation()?t.setFloat3(i,this.transformedPosition.x-e.x,this.transformedPosition.y-e.y,this.transformedPosition.z-e.z):t.setFloat3(i,this.position.x-e.x,this.position.y-e.y,this.position.z-e.z),this}prepareLightSpecificDefines(t,i){t["POINTLIGHT"+i]=!0}}b([A()],c.prototype,"shadowAngle",null);v("BABYLON.PointLight",c);const f="KHR_lights_punctual";class x{constructor(t){this.name=f,this._loader=t,this.enabled=this._loader.isExtensionUsed(f)}dispose(){this._loader=null,delete this._lights}onLoading(){const t=this._loader.gltf.extensions;if(t&&t[this.name]){const i=t[this.name];this._lights=i.lights,m.Assign(this._lights)}}loadNodeAsync(t,i,e){return g.LoadExtensionAsync(t,i,this.name,async(n,d)=>(this._loader._allMaterialsDirtyRequired=!0,await this._loader.loadNodeAsync(t,i,a=>{let o;const s=m.Get(n,this._lights,d.light),u=s.name||a.name;switch(this._loader.babylonScene._blockEntityCollection=!!this._loader._assetContainer,s.type){case"directional":{const h=new P(u,r.Backward(),this._loader.babylonScene);h.position.setAll(0),o=h;break}case"point":{o=new c(u,r.Zero(),this._loader.babylonScene);break}case"spot":{const h=new T(u,r.Zero(),r.Backward(),0,1,this._loader.babylonScene);h.angle=(s.spot&&s.spot.outerConeAngle||Math.PI/4)*2,h.innerAngle=(s.spot&&s.spot.innerConeAngle||0)*2,o=h;break}default:throw this._loader.babylonScene._blockEntityCollection=!1,new Error(`${n}: Invalid light type (${s.type})`)}o._parentContainer=this._loader._assetContainer,this._loader.babylonScene._blockEntityCollection=!1,s._babylonLight=o,o.falloffType=_.FALLOFF_GLTF,o.diffuse=s.color?p.FromArray(s.color):p.White(),o.intensity=s.intensity==null?1:s.intensity,o.range=s.range==null?Number.MAX_VALUE:s.range,o.parent=a,this._loader._babylonLights.push(o),g.AddPointerMetadata(o,n),e(a)})))}}C(f);S(f,!0,l=>new x(l));export{x as KHR_lights};
