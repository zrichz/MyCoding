import{R as n,a as l}from"./hdr-CfWvLTFH.js";import"./index-Dtj0WP_z.js";import"./index-Dw8Uzof1.js";import"./svelte/svelte_svelte.js";import"./svelte/svelte_animate.js";import"./svelte/svelte_attachments.js";import"./svelte/svelte_easing.js";import"./svelte/svelte_internal_client.js";import"./svelte/svelte_internal_flags_async.js";import"./svelte/svelte_internal_flags_legacy.js";import"./svelte/svelte_internal_flags_tracing.js";import"./svelte/svelte_internal_server.js";import"./svelte/svelte_legacy.js";import"./svelte/svelte_motion.js";import"./svelte/svelte_reactivity.js";import"./svelte/svelte_reactivity_window.js";import"./svelte/svelte_server.js";import"./svelte/svelte_store.js";import"./svelte/svelte_transition.js";import"./svelte/svelte_events.js";class M{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(a,o,m){const e=new Uint8Array(a.buffer,a.byteOffset,a.byteLength),r=n(e),p=l(e,r),s=r.width*r.height,i=new Float32Array(s*4);for(let t=0;t<s;t+=1)i[t*4]=p[t*3],i[t*4+1]=p[t*3+1],i[t*4+2]=p[t*3+2],i[t*4+3]=1;m(r.width,r.height,o.generateMipMaps,!1,()=>{const t=o.getEngine();o.type=1,o.format=5,o._gammaSpace=!1,t._uploadDataToTextureDirectly(o,i)})}}export{M as _HDRTextureLoader};
